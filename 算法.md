## 双指针
+ [LeetCode-33.搜索旋转排序数组](https://leetcode-cn.com/problems/search-in-rotated-sorted-array/)
    - 如果`nums[l] <= nums[mid]`，说明 mid 处在前半部分
        * 如果`nums[l] <= target && target < nums[mid]`，则`r = mid - 1`
        * 否则`l = mid + 1`，且此时还不能确定 target 处于前半部分还是后半部分
    - 如果`nums[0] > nums[mid]`，说明 mid 处在后半部分
        * 如果`nums[mid] < target && target <= nums[nums.length - 1]`，则`l = mid + 1`
        * 否则`r = mid - 1`，且此时还不能确定 target 处于前半部分还是后半部分
+ [LeetCode-81.搜索旋转排序数组Ⅱ](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/)
    - 与上题相同，注意左右边界和 mid 同时相等的情况，此时要`l++; r--;`
+ [LeetCode-34.在排序数组中查找元素的第一个和最后一个位置](https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/submissions/)
    - 双指针查找到元素，然后中心扩散
+ [LeetCode-69.Sqrt(x)](https://leetcode-cn.com/problems/sqrtx/)
    - 双指针指向 0 和 x
    - 计算 mid（注意溢出问题）
    - 判断 mid * mid 是否小于 x
        * 如果是则改变 low
        * 如果不是则改变 high
+ [LeetCode-75.颜色分类](https://leetcode-cn.com/problems/sort-colors/)
    - 双指针一次遍历
        * 设置两个指针`p0`和`p1`，专门用来交换 0 和 1
        * 如果遍历到一个数是 1，则将其与 p1 位置的数字交换，然后 p1 自增
        * 如果遍历到一个数是 0，则将其与 p0 位置的数字交换，当 p0 < p1 时说明已经遍历到过 1 了，那刚刚的交换其实把 1 交换了出去，这时候要再把 1 放回 p1 的位置，然后 p0 和 p1 自增

## 滑动窗口
+ [LeetCode-76.最小覆盖子串](https://leetcode-cn.com/problems/minimum-window-substring/)
    - 如果不满足覆盖子串条件，则`high++`
    - 如果已满足覆盖字串条件则`low++`，直到不满足，判断结果是否是最小的，如果是则替换

## 回溯
+ [LeetCode-22.括号生成](https://leetcode-cn.com/problems/generate-parentheses/submissions/)
    - 枚举`(`和`)`然后通过`isValid`判断是否符合下面的特点
    - 括号类题目的特点
        * 在任意一个位置，从开头到这个位置的左括号数量一定大于或等于右括号数量
        * 在任意一个位置，从开头到这个位置的左括号数量一定小于或等于长度的一半
+ [LeetCode-37.解数独](https://leetcode-cn.com/problems/sudoku-solver/)
    - 枚举`1, 2, 3, 4, 5, 6, 7, 8, 9`然后通过`isValid`判断是否符合下面的特点
    - 数独的特点
        * 方格内不能重复
        * 行不能重复
        * 列不能重复
+ [LeetCode-51.N 皇后](https://leetcode-cn.com/problems/n-queens/)
    - 在棋盘的每一个位置枚举`Q`，然后通过`isValid`判断是否符合下面的特点
    - 国际象棋的特点
        * 皇后可以横着走（可以以此为根据，在一行中枚举完`Q`之后直接开始在下一行开始枚举）
        * 皇后可以竖着走
        * 皇后可以斜着走
+ [LeetCode-39.组合总和](https://leetcode-cn.com/problems/combination-sum/)
    - 对于每一个数`i`，只有`i not in result`和`i in result`两种可能，枚举这两种可能
    - 需要注意的是题目中的数字可以被无限次使用，因此在`i in result`后递归下一个数字时`index`不用加 1
+ [LeetCode-40.组合总和 Ⅱ](https://leetcode-cn.com/problems/combination-sum-ii/submissions/)
    - 对于每一个数`i`，有`i not in result`，`i in result 1次`……`i in result n次`等可能，题目又要求返回结果不能重复，所以可以在枚举`i`时直接枚举它出现了多少次
    - 将给出的数组`candidates`进行分组，得到`List<int[]>`，其中每个`int[] arr`为
        * `arr[0]`为`candidates`中的某个数
        * `arr[1]`为`arr[0]`在`candidates`中出现的次数
    - 然后对`List<int[]>`中的所有元素，枚举其`arr[0]`出现 0 次到`arr[1]`次的所有可能情况
+ [LeetCode-46.全排列](https://leetcode-cn.com/problems/permutations/)
    - 将原数组分为前后两部分，前面的部分是已经确定了的，后面的部分是可以被枚举的
    - 假设原数组为`[1, 2, 3, 4]`
        * 当被分为`[1 | 2, 3, 4]`时，`2`这个位置可能的取值有`2, 3, 4`
        * 当被分为`[1 , 4 | 3, 2]`时，`3`这个位置可能的取值有`3, 2`
            + 遍历完以`1, 4`开头的结果后，记得要恢复`4`的位置（即回溯）
+ [LeetCode-47.全排列Ⅱ](https://leetcode-cn.com/problems/permutations-ii/)
    - 与上题一样，不过需要防止重复值，可以用`HashSet`去防止重复
    - **防止重复的思路是：在结果的位置 i 上不重复，则结果集就不会包含重复值**，所以应该按照位置 i 的可能性来枚举
+ [LeetCode-77.组合](https://leetcode-cn.com/problems/combinations/)
    - 在大小为`k`的结果数组`arr`中的每一个位置`index`，枚举所有大于`arr[index - 1]`且小于等于`n`的值
+ [LeetCode-93.复原 IP 地址](https://leetcode-cn.com/problems/restore-ip-addresses/)
    - `void place(char[] arr, int idx, int dotCount)`
    - `idx`记录当前遍历到的索引，初始值 0
    - `dotCount`记录当前放置了的点的数量，初始值 0
    - 每次有三种放置情况（两点之间的数字须符合`0`~`255`，通过`isValid`函数判断）
        * 在`idx`后放`.`
        * 在`idx + 1`后放`.`
        * 在`idx + 2`后放`.`

### 模板（以 N 皇后为例）
+ 提供一个可递归调用的方法如`putAtRow`
+ 提供一个用于判断当前操作是否符合特点的方法`isValid`（相当于剪枝）
+ 如果是符合特点的，则做标记并递归调用，递归完成后要清除标记

```java
class Solution {

    List<List<String>> result = new LinkedList<>();

    public List<List<String>> solveNQueens(int n) {
        if (n == 1) {
            return Arrays.asList(Arrays.asList("Q"));
        }

        String[][] chess = new String[n][n];
        for (String[] row: chess) {
            Arrays.fill(row, ".");
        }
        putAtRow(chess, 0);
        return result;
    }

    private void putAtRow(String[][] chess, int row) {
        if (row == chess.length) {
            // 结束递归，记录当前结果进 result
            List<String> list = new LinkedList<>();
            for (int i = 0; i < row; i++) {
                String str = "";
                for (int j = 0; j < row; j++) {
                    str += chess[i][j];
                }
                list.add(str);
            }
            result.add(list);
        }

        for (int col = 0; col < chess.length; col++) {
            if (!isValid(chess, row, col)) {
                continue;
            }
            // 做标记
            chess[row][col] = "Q";
            // 递归
            putAtRow(chess, row + 1);
            // 销毁标记
            chess[row][col] = ".";
        }
    }

    private boolean isValid(String[][] chess, int row, int col) {
        // 检查列上有无 Q
        for (int i = row - 1; i >= 0; i--) {
            if ("Q".equals(chess[i][col])) {
                return false;
            }
        }
        // 检查左上角有无 Q
        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0;) {
            if ("Q".equals(chess[i--][j--])) {
                return false;
            }
        }
        // 检查右上角有无 Q
        for (int i = row - 1, j = col + 1; i >= 0 && j < chess.length;) {
            if ("Q".equals(chess[i--][j++])) {
                return false;
            }
        }
        // 因为从最上面一行放到最下面，所以不用检查左下角和右下角
        return true;
    }
}
```

## 动态规划
### 字符串匹配
+ [LeetCode-10.正则表达式匹配（剑指Offer-19）](https://leetcode-cn.com/problems/regular-expression-matching/submissions/)
    - ![](https://cdn.nlark.com/yuque/0/2022/png/1732113/1642246880503-0564e260-cf1f-4e1d-bd1f-d07a0c31aef6.png)
    - 当`p[j]`不是星号时，看`p[j]`和`s[i]`是否匹配
        * 如果匹配则化为子问题`f[i - 1][j - 1]`
        * 不匹配则整体也不匹配
    - 当`p[j]`是星号时
        * 将`p[j - 1]`匹配 0 次的情况，则化为子问题`f[i][j - 2]`
        * 如果`p[j - 1] = s[i]`，则考虑将其匹配一次后仍保留`*`的情况，这样就会延申出`*`的多匹配，即`f[i - 1][j]`
+ [LeetCode-44.通配符匹配](https://leetcode-cn.com/problems/wildcard-matching/)
    - 有点像上面这道正则表达式匹配
    - 定义`boolean dp[s.length() + 1][p.length() + 1]`，`dp[i][j]`表示从 s 的开头到 i - 1 位置与从 p 的开头到 j - 1 位置是否匹配
    - ![](https://cdn.nlark.com/yuque/0/2022/png/1732113/1642490230750-5d55e46c-57e6-4ba1-8409-9af4c62bd992.png)
+ [LeetCode-72.编辑距离（CVTE 笔试题）](https://leetcode-cn.com/problems/edit-distance/)
    - 初始化边界
        * `f[0][j] = j`
        * `f[i][0] = i`
    - 插入一个字符相当于忽略掉`word2`的当前字符
        * `f[i][j] = f[i][j - 1] + 1`
    - 删除一个字符相当于忽略掉`word1`的当前字符
        * `f[i][j] = f[i - 1][j] + 1`
    - 替换一个字符相当于忽略掉`word1`和`word2`的当前字符
        * `f[i][j] = f[i - 1][j - 1] + 1`
    - 如果`word1`和`word2`的当前字符相等，则不进行任何操作
        * `f[i][j] = f[i - 1][j - 1]`

### 路径搜索
+ [LeetCode-62.不同路径](https://leetcode-cn.com/problems/unique-paths/submissions/)
    - ![](https://cdn.nlark.com/yuque/0/2022/png/1732113/1642492148152-e6c4643b-2b1b-4428-97ea-ba61197a468b.png)
+ [LeetCode-63.不同路径Ⅱ](https://leetcode-cn.com/problems/unique-paths-ii/)
    - ![](https://cdn.nlark.com/yuque/0/2022/png/1732113/1642495754470-d3467ef6-7561-46b1-bfc4-8bbfa0c037dd.png)
+ [LeetCode-64.最小路径和](https://leetcode-cn.com/problems/minimum-path-sum/)
    - `dp[i][j] = grid[i][j] + min(grid[i - 1][j], grid[i][j - 1])`
+ [剑指 Offer 47. 礼物的最大价值](https://leetcode-cn.com/problems/li-wu-de-zui-da-jie-zhi-lcof/)
    - ![image](https://cdn.nlark.com/yuque/__latex/e1d8bda88c1ed2f197611c32c9a644e6.svg)

### 背包问题
+ [LeetCode-322.零钱兑换](https://leetcode-cn.com/problems/coin-change/)
    - **完全背包问题，求最少零钱数**
    - **先遍历硬币还是先遍历背包都不影响结果**
    - `dp[i] = min(dp[i - coin] + 1, dp[i])`
+ [LeetCode-518.零钱兑换Ⅱ](https://leetcode-cn.com/problems/coin-change-2/)
    - **完全背包问题，求换零钱的方法数（实质上是求组合数，因为**`1 + 2`**和**`2 + 1`**是等价的）**
    - **求组合一定要先遍历物品，再遍历容量（也就是先遍历零钱，再遍历总和）**

```plain
硬币有[2, 3]，求要凑出 5 块钱的方法数
如果是先遍历硬币，再遍历钱
int[] coins = [2, 3]
int amount = 5
dp[0] = 1 // 0 块钱有 1 种凑法，即 dp[coin - coin] = 1，coin 块钱有 1 种凑法
for (int coin: coins) {
	for (int i = coin; i <= amount; i++) {
    	dp[i] += dp[i - coin]
    }
}
（1）当 coin = 2，i = 3 时，由于 2 无法凑成 3 块钱，故 dp[3] 此时还是 0
	因此到 dp[5] 时，dp[5] = dp[5 - 2] = dp[3] = 0
（2）当 coin = 3，i = 3 时，dp[3] = dp[i - coin] = dp[3 - 3] = dp[0] = 1
	因此到 dp[5] 时，dp[5] = dp[5 - 3] = dp[2] = 1

可以看出，先遍历硬币的结果是，如果 dp[i - coin] 不是 0，比如上面的 dp[5 - 3]，那么 dp[i - coin] 一定是用之前遍历过的 coin 拼凑出来的，这样的效果是结果对应的组合一定是新的，不重复的，因为这次为组合添加进了新元素，比如上面第二次遍历，就为结果 [2] 添加进了新元素 3
```

+ 零钱兑换Ⅱ的题外话
    - **如果是求排列数，比如**

```plain
有数字[2, 3]，求用这两个数构成的和为 5 的所有表达式（2 + 3 和 3 + 2不算重复）
则得先遍历结果，再遍历硬币
int[] nums = [2, 3]
int sum = 5
dp[0] = 1 // 2 = 2，3 = 3
for (int i = 0; i <= 5; i++) {
		for (int num: nums) {
    		if (i >= num) {
    				dp[i] += dp[i - num]
        }
    }
}
（1）当 i = 2，num = 2 时，dp[2] = 1
（2）当 i = 3，num = 3 时，dp[3] = 1
（3）当 i = 5，num = 2 时，dp[5] = dp[5] + dp[5 - 2] = 1
（4）当 i = 5，num = 3 时，dp[5] = dp[5] + dp[5 - 3] = 2

可以看出，先遍历加数的结果是，有可能出现效果相同但是顺序不同的结果，即求排列数
```

#### 背包问题总结
+ 0-1 背包问题
    - 一维 DP 数组从大到小遍历，先物品再容量，物品只能用一次
    - 二维 DP 数组从小到大遍历，先物品再容量或反过来也可以
+ 部分背包问题
    - 可以考虑化为 0-1 背包问题
+ 完全背包问题
    - 从小到大遍历，因为物品使用多少次都可以
    - 看求排列还是组合
        * 求组合一定要先遍历物品
        * 求排列一定要先遍历容量
+ **99% 的情况下先遍历物品都没错，除非求的是排列**

### 整数拆分
+ [LeetCode-343.整数拆分（剑指 Offer 14. 剪绳子Ⅰ）](https://leetcode-cn.com/problems/integer-break/)
    - ![image](https://cdn.nlark.com/yuque/__latex/1eec82e173a3fdd2763f9ad56b6faf69.svg)
    - 即最大乘积要么是之前**每一个的最大乘积**乘上**差距**，要么是之前的**每一个**乘上**差距**
+ [剑指 Offer 14. 剪绳子Ⅱ](https://leetcode-cn.com/problems/jian-sheng-zi-ii-lcof/)
    - 上道题的姊妹篇，因为数据太大题目提出可以取余，但是取余后放进`max`函数的结果是错的，如果还想像上题一样动态规划，可以考虑使用`BigInteger`

### 买股票
+ [LeetCode-121.买卖股票的最佳时机](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)
    - 维护从头到现在遇到的最小值`min = Math.min(min, prices[i])`
    - 判断利润是否大于此前的最大利润`max = Math.max(max, prices[i] - min)`
+ [LeetCode-122.买卖股票的最佳时机Ⅱ](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/)
    - **此题贪心法更合适**
        * 如果今天也递增就不卖
        * 如果今天跌了就**回到昨天**卖掉，然后今天重新买入
    - 在第 i 天结束后可以有几种情况
        * 没有股票`newNon = Math.max(non, has + prices[i])`
            + 第 i - 1 天也没有股票
            + 第 i - 1 天有股票，在第 i 天卖掉
        * 有股票`newHas = Math.max(has, non - prices[i])`
            + 第 i - 1 天也有股票
            + 第 i - 1天没有股票，在第 i 天买入
        * `non = newNon; has = newHas;`
+ [LeetCode-714.买卖股票的最佳时机含手续费](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/submissions/)
    - 在 122 动态规划的基础上扣除手续费
    - `newNon = Math.max(non, has + prices[i] - fee)`
    - `newHas = Math.max(has, non - prices[i])`
+ [LeetCode-309.最佳买卖股票时机含冷冻期](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/submissions/)
    - `dp[i][0][0]`第 i 天结束，不是冷冻期，没有股票
        * `max(dp[i - 1][1][0], dp[i - 1][0][0])`
    - `dp[i][1][0]`第 i 天结束，是冷冻期，没有股票
        * `= dp[i - 1][0][1] + prices[i]`
    - `dp[i][0][1]`第 i 天结束，不是冷冻期，有股票
        * `max(dp[i - 1][0][1], dp[i - 1][0][0] - prices[i])`
    - `dp[i][1][1]`不存在这种状态
+ [LeetCode-123.买卖股票的最佳时机Ⅲ](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/)
    - 同下题
+ [LeetCode-188.买卖股票的最佳时机Ⅳ](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/submissions/)

```java
class Solution {
    public int maxProfit(int k, int[] prices) {
        if (prices.length < 2) {
            return 0;
        }
        // dp[i][k][0]: 第 i 天结束后没有股票，已经买了 k 次股票
        //      = dp[i - 1][k][0]
        //      = dp[i - 1][k][1] + prices[i]
        // dp[i][k][1]: 第 i 天结束后有股票，已经买了 k 次股票
        //      = dp[i - 1][k][1]
        //      = dp[i - 1][k - 1][0] - prices[i]
        int[][][] dp = new int[prices.length][k + 1][2];
        for (int temp = 0; temp <= k; temp++) {
            // 赋初始值，假设第一天买了第 temp 次股票都是因为买入了第一只股票
            dp[0][temp][1] = -prices[0];
        }
		// 从第二天开始遍历
        for (int i = 1; i < prices.length; i++) {
            // 从买了第 1 只股票的情况开始遍历
            for (int j = 1; j <= k; j++) {
                dp[i][j][0] = Math.max(dp[i - 1][j][0], dp[i - 1][j][1] + prices[i]);
                dp[i][j][1] = Math.max(dp[i - 1][j][1], dp[i - 1][j - 1][0] - prices[i]);
            }
        }
        // 最后一天，买了 k 次，无股票状态
        return dp[prices.length - 1][k][0];
    }
}
```

### 杂项
+ [LeetCode-42.接雨水](https://leetcode-cn.com/problems/trapping-rain-water/submissions/)
    - 对于每一个位置 i，如果知道这个位置的左右两边最高的柱子，即可算出这个位置能接的雨水
    - `leftMax[i] = max(leftMax[i - 1], height[i])`
        * `leftMax[0] = height[0]`
    - `rightMax[i] = max(rightMax[i + 1], height[i])`
        * `rightMax[length - 1] = height[length - 1]`
    - 对于位置 i，能接的雨水即为左右两边的短板减去自身高度
        * `Math.min(leftMax[i], rightMax[i]) - height[i]`
+ [LeetCode-53.最大子数组和](https://leetcode-cn.com/problems/maximum-subarray/)
    - ![](https://cdn.nlark.com/yuque/0/2022/png/1732113/1642490916637-9ebd6c0d-7eef-47b1-b843-921ff2239545.png)
+ [LeetCode-55.跳跃游戏](https://leetcode-cn.com/problems/jump-game/)
    - ![](https://cdn.nlark.com/yuque/0/2022/png/1732113/1642491883351-6f049938-1654-42a8-b0f6-2aea55000e56.png)

## 递归
+ [LeetCode-25. K 个一组翻转链表](https://leetcode-cn.com/problems/reverse-nodes-in-k-group/)
    - 采用[LeetCode-206.反转链表](https://leetcode-cn.com/problems/reverse-linked-list/)递归即可获得新链表的头结点的思路就可以仅使用常数空间
    - 定义递归函数`reverse(ListNode node, int k)`
        * 当`node == null`时返回`null`
        * 当`k == 1`时说明已经遍历到一组的末尾了，需要
            + 返回当前结点`node`，作为这一组的开头
            + 将`node.next`存到一个地方`nextHead`，作为下一次开始反转的起点
        * 当`k != 1`时，递归调用`reverse(node.next, k - 1)`
            + 然后`node.next.next = node`直接就地反转
    - 外层控制递归函数，从`head`开始处理分组
        * 当`reverse`返回`null`说明可以结束了，因为最后不成 K 个一组的结点不用进行反转
        * 当`reverse`不返回`null`则需要继续从`nextHead`继续开始分组
        * 需要记录上一个分组的最后节点`lastNode`，`lastNode.next = reverse的结果`
+ [LeetCode-124.二叉树中的最大路径和](https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/)
    - 递归调用，方法返回值为`node.val + max(left, right)`
    - `left = max(generate(node.left), 0)`
    - `right = max(generate(node.right), 0)`
    - `result = max(result, node.val + left + right)`
        * 因为答案可能是经过左右子树的，所以在这里更新答案，但是返回给上一个递归调用的方法时只可以选左右子树其中一个，因为对于上层结点无法同时访问左右子树

## 分治
+ [LeetCode-23. 合并K个升序链表](https://leetcode-cn.com/problems/merge-k-sorted-lists/)
    - 先写出[LeetCode-21. 合并两个有序链表](https://leetcode-cn.com/problems/merge-two-sorted-lists/)，然后两两合并
+ [LeetCode-395.至少有 K 个重复字符的最长子串](https://leetcode-cn.com/problems/longest-substring-with-at-least-k-repeating-characters/submissions/)
    - 数出区间`[l, r]`中所有字符的数量，找有无小于 K 个的字符
        * 如果有，则标记以该字符（假设下标`split`）为分界，递归搜索`[l, split - 1]`和`[split + 1, r]`
        * 如果没有更新结果`result = Math.max(result, r - l + 1)`

## 深度 / 广度 优先搜索
+ [LeetCode-79.单词搜索](https://leetcode-cn.com/problems/word-search/)
    - 深度优先搜索，使用`boolean[][] walked`记录是否走过当前位置
    - `illegalBorder(board, x, y) || word.charAt(i) != board[x][y] || walked[x][y]`时直接返回 false
    - `word.charAt(i) == board[x][y] && i == word.length() - 1`时返回 true
    - **此题需要回溯，即退出方法时记得将**`walked[x][y]`复原为 false

## 数据结构
### 栈
+ [LeetCode-71.简化路径](https://leetcode-cn.com/problems/simplify-path/submissions/)
    - 关键是先将路径`split("/")`，然后就是入栈和出栈操作
        * `.`或空字符串可以忽略，因为还在当前目录
        * `..`出栈
        * 其余情况入栈

#### 单调栈
+ [LeetCode-84.柱状图中最大的矩形](https://leetcode-cn.com/problems/largest-rectangle-in-histogram/)
    - 栈内保存高度单调递增的柱子的下标
    - 入栈时，要出栈比自己高的柱子，因为它们的右边界已经确定了（就是当前遍历的位置，因为当前比他们都矮）
    - 出栈时，右边界由导致现在出栈的柱子决定（遍历到哪？如果已经遍历完了可以视为遍历到一根高度为 0 的柱子，迫使现在得出栈），然后执行出栈操作，左边界由栈内的栈顶元素决定（因为栈顶元素与出栈的元素之间的柱子肯定是比他们都高的），如果栈中没有元素则由最近一个高度为 0 的柱子的位置决定

```java
class Solution {

    public int largestRectangleArea(int[] heights) {
        // 保持栈单调递增
        Deque<Integer> deque = new LinkedList<>();
        int ans = 0, top;
        for (int i = 0; i < heights.length; i++) {
            // 如果当前位置小于栈顶则一直出栈，然后计算出栈结果是否可以更新结果
            while (!deque.isEmpty() && heights[deque.peek()] > heights[i]) {
                top = deque.pop();
				// 判断左边界，当栈空时为最近一次出现的 0 的位置即为 -1
                // 当栈不为空时为栈顶
                int leftBorder = deque.isEmpty() ? -1 : deque.peek();
				// 右边界（不包含）即为 i
                ans = Math.max(ans, (i - leftBorder - 1) * heights[top]);
            }

            deque.push(i);
        }

        while (!deque.isEmpty()) {
            top = deque.pop();

            int leftBorder = deque.isEmpty() ? -1 : deque.peek();

            ans = Math.max(ans, (heights.length - leftBorder - 1) * heights[top]);
        }
        return ans;
    }
}
```

### 堆
+ [剑指 Offer 59.滑动窗口的最大值](https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof/)
    - 通过`new PriorityQueue<>((a, b) -> -a.compareTo(b))`构建大根堆
+ [剑指 Offer 40. 最小的 K 个数](https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof/)
    - 本题也可以通过快排等其他方式实现
    - 构建堆
    - 删除 K - 1 个数后取根节点

```java
class Solution {

    int size;

    public int[] getLeastNumbers(int[] arr, int k) {
        if (k == 0) {
            return new int[0];
        }
        size = arr.length;
        int[] result = new int[k];
        // 构建堆
        buildHeap(arr);
        // 弹出 k - 1 次，返回堆顶
        while (k > 1) {
            result[k - 1] = arr[0];
            swap(arr, 0, size - 1);
            size--;
            shiftDown(arr, 0);
            k--;
        }
        result[k - 1] = arr[0];
        return result;
    }

    /**
     * 构建堆的算法
     */
    private void buildHeap(int[] arr) {
        // 计算出最后一个非叶子节点
        int parent = (size - 1) / 2;
        while (parent >= 0) {
            // 从最后一个非叶子节点 shiftDown
            shiftDown(arr, parent);
            parent--;
        }
    }

    private void shiftDown(int[] arr, int root) {
        int l = root * 2 + 1;
        int r = root * 2 + 2;
        if (l >= size) {
            // 叶子节点
            return ;
        } else if (r >= size) {
            // 只有左孩子
            if (arr[root] > arr[l]) {
                swap(arr, root, l);
                shiftDown(arr, l);
            }
        } else {
            // 有左右孩子
            if (arr[root] > arr[l] || arr[root] > arr[r]) {
                if (arr[l] <= arr[r]) {
                    swap(arr, l, root);
                    shiftDown(arr, l);
                } else {
                    swap(arr, r, root);
                    shiftDown(arr, r);
                }
            } 
        }
    }

    private void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }
}
```

### 图
#### 图的构建、遍历
+ [LeetCode-797.所有可能的路径](https://leetcode-cn.com/problems/all-paths-from-source-to-target/)
    - 图的基本遍历
        * 构造图
            + `List<Integer>[] graph = new LinkedList[xxx]`
            + `int[][] graph = new int[xxx][xxx]`
        * `traverse(graph, i)`
+ [LeetCode-207.课程表](https://leetcode-cn.com/problems/course-schedule/)
    - 判断图是否带环
    - `boolean[] visited`用于标记节点是否访问过，访问过的不用再遍历（为什么？）
        * 访问过的节点不会和当前节点成环，因为如果真的成环了则当前节点早就被访问了，由访问过的节点不用再遍历可以得知正在遍历的节点一定还没访问过
    - `boolean[] onPath`用于标记当前路径上的节点，借此判断是否成环
+ [LeetCode-210.课程表Ⅱ](https://leetcode-cn.com/problems/course-schedule-ii/submissions/)
    - 判断图是否带环
    - **拓扑排序**，**后序遍历**图，然后再将遍历结果反转
        * 前序不行吗？

前序遍历的话不知道当前课程是否有其他前置课程，如 `[[0 -> 1], [2 -> 0]]`，在遍历完`0 -> 1`时 postOrder 为`[0, 1]`，并不知道后面还有`2 -> 0`

        * 后序遍历的好处？

`0 -> 1`遍历完的 postOrder 为`[1, 0]`，遍历`2 -> 0`时发现 0 已经遍历过，则 postOrder 为`[1, 0, 2]`，反转后得到结果为`[2, 0, 1]`

后序遍历相当于把自己的依赖项都先遍历，然后最后再遍历自己

    - [https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247491897&idx=1&sn=c2d77dd649548d077815af3c976b61d1&scene=21#wechat_redirect](https://mp.weixin.qq.com/s?__biz=MzAxODQxMDM0Mw==&mid=2247491897&idx=1&sn=c2d77dd649548d077815af3c976b61d1&scene=21#wechat_redirect)

#### Dijkstra 算法——求最短路径
+ [LeetCode-743.网络延迟时间](https://leetcode-cn.com/problems/network-delay-time/)
    - 维护一个从起点到每一个节点的数组`distTo`
    - 构造图
    - 构造优先级队列`PriorityQueue`，按与起点的距离从小到大排序，然后 BFS
+ [LeetCode-1514.概率最大的路径](https://leetcode-cn.com/problems/path-with-maximum-probability/)
    - 维护一个从起点到每一个节点的概率数组`probabilityTo`
    - 构造图（注意无向图的构造方式）
    - 构造优先级队列`PriorityQueue`，按从起点到该节点的概率从大到小排序，然后 BFS
    - 若遍历到终点即可直接返回结果（为什么？）
        * 因为越往后面走概率越小，即使还有其他的路可以通往终点，概率也没有当前的大
+ [LeetCode-1631.最小体力消耗路径](https://leetcode-cn.com/problems/path-with-minimum-effort/submissions/)
    - 构造图
    - 维护一个从起点到每一个节点的体力数组`healthTo`
    - 构造优先级队列`PriorityQueue`，按从起点到该节点的体力从小到大排序，然后 BFS
    - 若遍历到终点即可直接返回结果（为什么？）
        * 因为越往别的路走体力越大，即使还有其他的路可以通往终点，但是由于`PriorityQueue`是按照体力大小排序的，所以也没有当前消耗的体力小
+ [LeetCode-815.公交路线](https://leetcode-cn.com/problems/bus-routes/submissions/)
    - 构造图，以站点构造图在遇到极端测试用例会超时间，可以先按站点 - 站点有的公交路线先构造一个 Map，然后再构造公交路线的图，`Map<Integer, List<Integer>>`表示 key 号路线可以转到 value 集合中的任意一路
    - 维护一个起点到每一个终点路线的站数`Map<Integer, Integer>`
    - 构造优先级队列`PriorityQueue`，按从起点到该节点的站数从小到大排序，然后 BFS

#### 二分图的判定
+ [LeetCode-785.二分图的判定](https://leetcode-cn.com/problems/is-graph-bipartite/)
    - 使用`visited`标记节点是否访问过
    - 在遍历当前节点可达的节点时
        * 如果可达节点还未访问过，即`!visited[i]`，则标记颜色后放入队列
        * 如果可达节点已经访问过，即`visited[i]`，则判断当前节点与可达节点的颜色是否相反，如果不相反直接返回答案
+ [LeetCode-886.可能的二分法](https://leetcode-cn.com/problems/possible-bipartition/)
    - 同上题

#### Kruskal 求最小生成树
+ 最小生成树的几个特点
    - 不存在环
    - 所有节点都连接
    - 权重最小
+ Kruskal + 并查集 求最小生成树
    - 利用并查集来判断添加了边后是否存在环：如果两个点的`root`相同，则连起来后一定出现环
    - 所有节点都连接：所有边连完后，并查集的连通量为 1
    - 权重最小：Kruskal 算法，每次都取权重最小的边（通过`PriorityQueue`维护），然后判断取完是否出现环
+ [LeetCode-1584.连接所有点的最小费用](https://leetcode-cn.com/problems/min-cost-to-connect-all-points/)
    - 构造边的优先队列，按照权重排序

### 并查集
```java
package struct;

import java.util.Arrays;

/**
 * @author Pa
 * @date 2022/1/27 17:59
 */
public class UnionFind {

    int count;

    int[] parent;

    int[] size;

    public UnionFind(int n) {
        this.count = n;
        this.parent = new int[n];
        this.size = new int[n];
        Arrays.fill(size, 1);
        for (int i = 0; i < n; i++) {
            // 一开始自己的根节点就是自己
            parent[i] = i;
        }
    }

    public void union(int i, int j) {
        int rootI = findRoot(i);
        int rootJ = findRoot(j);

        if (rootI == rootJ) {
            // 已连通
            return;
        }

        if (size[rootI] > size[rootJ]) {
            // 左边的更高，右边的接到左边
            parent[rootJ] = rootI;
            size[rootI] += size[rootJ];
        } else {
            parent[rootI] = rootJ;
            size[rootJ] += size[rootI];
        }
        this.count--;
    }

    public boolean isUnion(int i, int j) {
        // 连通情况下根节点相同
        return findRoot(i) == findRoot(j);
    }

    public int getCount() {
        // 连通分量
        return count;
    }

    private int findRoot(int i) {
        // 根节点有 parent[i] == i
        while (parent[i] != i) {
            // 路径压缩
            parent[i] = parent[parent[i]];
            i = parent[i];
        }
        return i;
    }
}
```

### 平衡二叉查找树 AVL
+ 左右子树高度差不超过 1
+ LL 右旋
+ RR 左旋
+ LR 先左旋再右旋
+ RL 先右旋再左旋

### 红黑树
+ 调整频率低于平衡查找二叉树，平衡性没有 AVL 好
+ 插入、删除较少，查找较多的场景，AVL 树更好
+ 特性
    - 每个节点要么是红色的，要么是黑色的
    - 根节点一定是黑色的
    - 每个叶子节点（NIL）是黑色的
    - 红色节点的孩子一定是黑色的
    - 对于每一个节点，它的所有到达叶子节点的简单路径包含相同数量的黑色节点
        * 如果一个节点存在黑色子节点，那么一定存在两个子节点，但不一定都是黑色
+ 平衡性：log2(n + 1) <=  h <= 2log2(n + 1)
    - 其高度仍控制在**最小高度**的两倍以内，复杂度仍趋于 logn，保证了适度平衡
+ 

## 字符串拆分
+ [LeetCode-71.简化路径](https://leetcode-cn.com/problems/simplify-path/submissions/)：按`/`拆分后再继续
+ [LeetCode-165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)：按`.`拆分后再继续，`str.split("\\.")`，需要转义
+ [LeetCode-65.有效数字](https://leetcode-cn.com/problems/valid-number/)：按`e`或`E`拆分后，分别判断前后部分是否为数字，否则判断全部是否为数字

## N 数之和
+ [LeetCode-18.四数之和](https://leetcode-cn.com/problems/4sum/)
+ [LeetCode-15.三数之和](https://leetcode-cn.com/problems/3sum/)

```java
class Solution {

    List<List<Integer>> result = new LinkedList<>();
    LinkedList<Integer> tempList = new LinkedList<>();

    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        nSum(nums, 0, target, 4);
        return result;
    }

    private void nSum(int[] nums, int start, int target, int n) {
        if (n == 2) {
            int low = start, high = nums.length - 1;
            Integer last = null;
            while (low < high) {
                if (last != null && nums[low] == last) {
                    low++;
                } else {
                    int sum = nums[low] + nums[high];
                    if (sum == target) {
                        last = nums[low];
                        List<Integer> list;
                        result.add(list = new ArrayList<>(tempList));
                        list.add(nums[low++]);
                        list.add(nums[high--]);
                    } else if (sum < target) {
                        low++;
                    } else {
                        high--;
                    }
                }
            }
        } else {
            Integer last = null;
            for (int i = start; i < nums.length - n + 1; i++) {
                if (last != null && last == nums[i]) {
                    continue;
                }
                tempList.offerLast(nums[i]);
                last = nums[i];
                nSum(nums, i + 1, target - nums[i], n - 1);
                tempList.pollLast();
            }
        }
    }
}
```

## RandN()
1. 用`rand2()`构造`rand4()`，可通过`(rand2() - 1) * 2`和`rand2()`相加来构造

| rand2() | 1 | 2 |
| --- | --- | --- |
| 1 | 0 = (1 - 1) * 2 + 1 | 1 = (1 - 1) * 2 + 2 |
| 2 | 2 = (2 - 1) * 2 + 1 | 3 = (2 - 1) * 2 + 2 |


2. 推广到`randN()`，则可以构造出`randN*N()`

```java
int randN_N() {
	return (randN() - 1) * N + randN();
}

// 如果给出 randX() 和 randY()，也可以直接构造出 randX_Y()
int randX_Y() {
 	return (randX() - 1) * Y + randY();   
}
```

3. 如果两个数不成倍数关系，可以通过拒绝采样舍弃部分随机结果，如`rand7()`构造`rand10()`

```java
int rand10() {
 	while (true) {
     	int row = rand7();
        int col = rand7();
        // rand49
        int i = (row - 1) * 7 + col;
        if (i <= 40) {
            // rand40
         	return i % 10 + 1;
        }
    }
}
```

## LRU 算法 / LFU 算法
+ [LeetCode-146.LRU缓存](https://leetcode-cn.com/problems/lru-cache/)
+ [LeetCode-460.LFU缓存](https://leetcode-cn.com/problems/lfu-cache/)
    - `Map<Integer, Node> cache` 值缓存
    - `Map<Integer, List<Node>> frequentMap` 频次缓存
    - `Node {int key; int val; int frequent;}`
+ `HashMap`和手写链表版本

```java
class LRUCache {

    private Map<Integer, Node> map;
    private int capacity;
    private Node head = new Node();
    private Node tail = new Node();

    public LRUCache(int capacity) {
        map = new HashMap<>(capacity);
        this.capacity = capacity;
        head.next = tail;
        tail.prev = head;
    }

    public int get(int key) {
        Node node = map.get(key);
        if (node == null) {
            return -1;
        }
        moveToHead(node);
        return node.val;
    }

    public void put(int key, int value) {
        Node node = map.get(key);
        if (node == null) {
            node = new Node(key, value);
            map.put(key, node);
            // 淘汰最旧的
            if (map.size() > capacity) {
                map.remove(tail.prev.key);
                remove(tail.prev);
            }
            addToHead(node);
        } else {
            node.val = value;
            moveToHead(node);
        }
    }

    private void moveToHead(Node node) {
        remove(node);
        addToHead(node);
    }

    private void remove(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
    }

    private void addToHead(Node node) {
        node.prev = head;
        node.next = head.next;
        head.next.prev = node;
        head.next = node;
    }

    static class Node {
        Node prev;
        Node next;
        int key;
        int val;

        Node() {}

        Node(int key, int val) {
            this.key = key;
            this.val = val;
        }
    }
}
```

+ `LinkedHashMap`版本

```java
class LRUCache {

    private Map<Integer, Integer> map;

    public LRUCache(int capacity) {
        map = new LinkedHashMap<> (capacity, 0.75f, true) {

            @Override
            protected boolean removeEldestEntry(Map.Entry eldest) {
                return size() > capacity;
            }
        };
    }

    public int get(int key) {
        return map.getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        map.put(key, value);
    }
}
```

## KTop
+ 快排分区思想

```java
class Solution {
    
    public int findKthLargest(int[] nums, int k) {
        int index, target = nums.length - k, l = 0, r = nums.length - 1;
        while (true) {
            index = partition(nums, l, r);
            if (index == target) {
                return nums[index];
            } else if (index < target) {
                l = index + 1;
            } else {
                r = index - 1;
            }
        }
    }

    private int partition(int[] nums, int l, int r) {
        int pivot = l;
        while (l < r) {
            while (l < r && nums[pivot] <= nums[r]) {
                r--;
            }
            swap(nums, r, pivot);
            pivot = r;
            while (l < r && nums[pivot] >= nums[l]) {
                l++;
            }
            swap(nums, l, pivot);
            pivot = l;
        }
        return pivot;
    }

    private void swap(int[] nums, int l, int r) {
        int temp = nums[l];
        nums[l] = nums[r];
        nums[r] = temp;
    }
}
```

+ 手写堆排序思想见[堆](#lPxmW)
+ `PriorityQueue`版本

```java
class KTop_3 {

    public int findKthLargest(int[] nums, int k) {
        PriorityQueue<Integer> queue = new PriorityQueue<>();
        for (int i : nums) {
            queue.add(i);
            if (queue.size() > k) {
                queue.poll();
            }
        }
        return queue.poll();
    }
}
```

## 二叉树迭代遍历
### 前序
```java
public void preOrder(TreeNode root) {
    // 注意 ArrayDeque 不允许 null 元素，如果要用 ArrayDeque 需要在 offer 前判空
    Deque<TreeNode> deque = new LinkedList<>();
    deque.offerFirst(root);
    while (!deque.isEmpty()) {
        TreeNode node = deque.poll();
        if (node == null) continue;
        
        doSomething(node);
        
        // 右
        deque.offerFirst(node.right);
        // 左右
        deque.offerFirst(node.left);
    }
}

private void doSomething(TreeNode node) {}
```

### 中序
```java
public void inOrder(TreeNode root) {
    if (root == null) return;
    // 使用 栈 存放中间点
    Deque<TreeNode> deque = new LinkedList<>();
    do {
        while (root != null) {
            deque.offerLast(root);
            root = root.left;
        }
        // 已经走到最左边，即没有左孩子
        root = deque.pollLast();
        // 中序遍历
        doSomething(root);
        // 然后遍历右孩子
        root = root.right;
        // 注意到 deque is empty 时有可能还没遍历完
    } while (root != null || !deque.isEmpty());
}

private void doSomething(TreeNode node) {}
```

### 后序
```java
// 思路一：前序遍历 中左右 -> （调整左右顺序）中右左 -> （结果反转）左右中 即后序遍历结果
List<TreeNode> result = new LinkedList<>();
public void postOrder(TreeNode root) {
    // 注意 ArrayDeque 不允许 null 元素，如果要用 ArrayDeque 需要在 offer 前判空
    Deque<TreeNode> deque = new LinkedList<>();
    deque.offerFirst(root);
    while (!deque.isEmpty()) {
        TreeNode node = deque.poll();
        if (node == null) continue;
        
        doSomething(node);
        
        // 左
        deque.offerFirst(node.left);
        // 右左
        deque.offerFirst(node.right);
    }
    Collections.reverse(result);
}

private void doSomething(TreeNode node) { result.add(node); }

// 思路二：真正地后序遍历
public void postOrder(TreeNode root, Void void) {
    Deque<TreeNode> deque = new LinkedList<>();
    while (root != null || !deque.isEmpty()) {
        while (root != null) {
            deque.offerLast(root);
            if (root.left != null) {
                 root = root.left;
            } else {
                 root = root.right;   
            }
        }
        // 走到这里说明上一个节点是叶子节点，遍历它
        root = deque.pollLast();
        
        doSomething(root);
        
        if (!deque.isEmpty() && deque.peekLast().left == root) {
            // 判断是否从左子树过来的，如果是的话则还需遍历栈顶的右子树
            root = deque.peekLast().right;
        } else {
            // 不是的话直接置空，获取下一个栈顶
            root = null;
        }
    }
}
```

## 前缀树（字典树）
+ [LeetCode-208.实现 Trie（前缀树）](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)
+ [LeetCode-648.单词替换](https://leetcode-cn.com/problems/replace-words/)
+ [LeetCode-211.添加与搜索单词](https://leetcode-cn.com/problems/design-add-and-search-words-data-structure/)
    - `search`方法需要支持深度优先搜索
+ [LeetCode-677.键值映射](https://leetcode-cn.com/problems/map-sum-pairs/)
    - `sum`方法需要其他方法支持深度优先搜索
+ [LeetCode-212.单词搜索Ⅱ](https://leetcode-cn.com/problems/word-search-ii/)
    - 将`words`放进前缀树，然后对`board`的每一个位置进行 dfs，若该位置对应的`node == null`则剪枝

```java
class Trie {
	// 根据需要调整扩展大小
    Trie[] children = new Trie['z' + 1];
    boolean exists = false;
    
    public void insert(String word) {
        getNode(word, true).exists = true;
    }
    
    public boolean search(String word) {
        Trie trie = getNode(word, false);
        return trie != null && trie.exists;
    }
    
    public boolean startsWith(String prefix) {
        return getNode(prefix, false) != null;
    }

    private Trie getNode(String key, boolean createIfNotExist) {
        Trie trie = this;
        for (int i = 0; i < key.length(); i++) {
            char c = key.charAt(i);
            if (trie.children[c] == null) {
                if (createIfNotExist) {
                    trie.children[c] = new Trie();
                } else {
                    return null;
                }
            }

            trie = trie.children[c];
        }
        return trie;
    }
}
```

## 前缀和
+ [LeetCode-560. 和为 K 的子数组](https://leetcode-cn.com/problems/subarray-sum-equals-k/)

```java
    int[] nums = {2, 3, 5, 1, 4};
    int[] sub = {0, 2, 5, 10, 11, 15};

    public int sub(int i, int j) {
         return sub[j + 1] - sub[i]   
    }
   
    /**
     * key:   sub[j + 1] - target (sub[i])
     * value: exist counts
     */
    Map<Integer, Integer> subMap = new HashMap() {
        {
            // sub[0] exist 1 time
            put(0, 1);
        }
    };

    /**
     * 子数组的和与 target 相等的个数
     */
    public int contains(int target) {
        // from i to j, target = sub[j + 1] - sub[i]
        // sub[i] = sub[j + 1] - target
        int count = 0;
        for (int j = 0; j < nums.length; j++) {
            int key = sub[j + 1] - target;
            if (subMap.containsKey(key)) {
                count += subMap.get(key);
            }
            subMap.put(sub[j + 1], subMap.getOrDefault(sub[j + 1], 0) + 1);
        }
        return count;
    }
```

