## 服务端处理客户端请求
![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1626354714576-b9eb6e0e-4eb3-49be-a684-127d6fe1c4fc.png)

+ 服务端处理客户端请求需要经过三个部分，连接管理、解析与优化、存储引擎
+ 连接管理

每当有客户端进程连接到服务器进程时，服务器进程会创建一个线程与客户端进行交互，客户端退出时，服务端不会立刻销毁线程，而是缓存此线程等待另一个新的客户端连接，分配给新的这个客户端。

线程分配的太多会严重影响系统性能，所以需要限制可以同时连接到服务器的客户端数量。

+ 解析与优化
    - 查询缓存**（在8.0中删除）**

会把刚刚处理过的查询请求和结果缓存起来，如果下一次有一模一样的请求过来，直接从缓存中查找结果。但是不缓存某些系统函数、用户自定义变量和函数、一些系统表。比如函数NOW，每次调用都应该产生最新的当前时间。

当对表使用了INSERT、UPDATE、DELETE、truncate、alter、drop等语句时，该表的所有高速缓存都应该被删除。

虽然查询缓存有时可以提升系统性能，但也不得不因维护这块缓存而造成一些开销，比如每次都要去查询缓存中检索，查询请求处理完需要更新查询缓存，维护该查询缓存对应的内存区域。**从MySQL 5.7.20开始，不推荐使用查询缓存，并在MySQL 8.0中删除。**

    - 语法解析  一个编译过程
    - 查询优化
+ 存储引擎

默认InnoDB，此外还有MyISAM，Memory等。

创建表时可以指定存储引擎，也可以修改表的存储引擎：

```sql
CREATE TABLE table_name (
		...
) ENGINE = engine_name;

ALTER TABLE table_name ENGINE = engine_name;
```

## InnoDB 与其他存储引擎的对比
### MyISAM
+ `MyISAM`**不支持事务**，而`InnoDB`支持
+ `MyISAM`不支持外键
+ `MyISAM`是非聚簇索引（尽管也采用 B+ 树），索引（主键索引和辅助索引）保存的是指向数据文件中某一条记录的指针
+ `MyISAM`的最小锁粒度是表锁，更新时会锁住整张表
+ 使用场景
    - 数据基本只需要读操作，不需要事务功能，可以接受崩溃导致的部分数据丢失

### Memory
+ 每个表最多可以有 32 个索引
+ 支持hash索引和b+树索引（默认hash索引）
+ 不支持 blog 和 text 等大字段
+ 使用表级锁
+ 表的最大大小由 max_heap_table_size 决定，默认 16 MB

## 启动选项和配置文件
+ 同时接入的客户端默认数量是151
+ 表的默认存储引擎是InnoDB
+ 服务端启动参数
    - `--skip-networking`将禁止客户端使用`TCP/IP`通信（即客户端不可以通过-h参数指定主机名连接）
    - `--default-storage-engine`将指定表的默认存储引擎，此参数默认值为`InnoDB`
    - `<font style="color:rgb(51, 51, 51);background-color:rgb(248, 248, 248);">--defaults-extra-file</font>`指定额外的配置文件
    - `--max-connections`指定最大连接数
+ 客户端启动参数
    - `-h` `--host` 主机名
    - `-u` `--user` 用户名
    - `-p` `--password` 密码
    - `-P` `--port` 端口
    - `-V` `--version` 版本信息

## 字符集和比较规则
+ 字符集
    - ASCII（1字节）
    - ISO-8859-1（也叫latin1，1字节）
    - GB2312（ASCII中的为1字节，否则2字节）
    - GBK（在GB2312的基础上扩充）
    - utf8（utfmb4为1～4字节，utfmb3为1～3字节）
+ MySQL中的utf8和utf8mb4
    - utf8即utf8mb3，阉割过的utf8字符集，包括很多常用字符
    - utf8mb4包含了emoji等
+ 比较规则

`utf8`默认比较规则为`utf8_general_ci`，其中ci代表不区分大小写（ai不区分重音，as区分重音，cs区分大小写，bin以二进制方式比较）

+ MySQL中的字符集转换
    - character_set_client         服务器解码请求时使用的字符集
    - character_set_connection 服务器处理请求时会把请求字符串从character_set_client转为character_set_connection
    - character_set_results       服务器向客户端返回数据时使用的字符集

```sql
mysql> show variables like '%character_%';
+--------------------------+--------------------------------------------------------+
| Variable_name            | Value                                                  |
+--------------------------+--------------------------------------------------------+
| character_set_client     | utf8mb4                                                |
| character_set_connection | utf8mb4                                                |
| character_set_database   | utf8mb4                                                |
| character_set_filesystem | binary                                                 |
| character_set_results    | utf8mb4                                                |
| character_set_server     | utf8mb4                                                |
| character_set_system     | utf8mb3                                                |
| character_sets_dir       | /usr/local/mysql-8.0.25-macos11-x86_64/share/charsets/ |
+--------------------------+--------------------------------------------------------+
8 rows in set (0.01 sec)
```

    - 一般情况下客户端使用的字符集和当前操作系统一致，类Unix系统使用utf8，Windows使用GBK

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1626423072547-36b88ced-6bdd-4564-a231-733c5760ea04.png)

    - 服务端认为客户端发送过来的请求是用`character_set_client`编码的

客户端采用的字符集和`character_set_client`不一样时会出现意想不到的情况，服务端无法处理。

    - 服务端把得到的结果集使用`character_set_results`编码后发送给客户端

客户端采用的字符集和`character_set_results`不同时，可能出现乱码。

    - `character_set_connection`只是服务器将请求的字符串从`character_set_client`转换为`character_set_connection`时使用，需注意此字符集包含的字符范围一定要涵盖请求中的字符。

举个例子，`character_set_client`为`utf8`，`character_set_connection`为`ascii`，那么客户端发送一个汉字到服务器时，服务器在上图第3步就无法编码这个汉字。

    - 使用`SET NAMES character_set_name;`来同时设置上述三个字符集



## InnoDB记录结构
### InnoDB页简介
读写磁盘的速度非常慢，和内存读写差了几个量级。InnoDB采取的方式是，将数据分为若干个页，以页作为磁盘和内存之间交互的基本单位。

**InnoDB中页的大小一般为16KB。也就是说，在一般情况下，一次最少从磁盘中读取16KB的内容到内存中，一次最少把内存中16KB的内容刷新到磁盘中。**

### InnoDB行格式
InnoDB到目前为止有4种行格式，分别是`Compact`、`Redundant`、`Dynamic`、`Compressed`。

#### 指定行格式
```sql
CREATE TABLE table_name ... ROW_FORMAT = [行格式名称];
ALTER TABLE table_name ROW_FORMAT = [行格式名称];
```

#### 例子
```sql
create table record_format_demo (
    c1 VARCHAR(10),
    c2 VARCHAR(10) NOT NULL,
    c3 CHAR(10),
    c4 VARCHAR(10)
) CHARSET = ascii ROW_FORMAT = COMPACT;

insert into record_format_demo VALUES ('aaaa', 'bbb', 'cc', 'd'), ('eeee', 'fff', NULL, NULL);

mysql> select * from record_format_demo;
+------+-----+------+------+
| c1   | c2  | c3   | c4   |
+------+-----+------+------+
| aaaa | bbb | cc   | d    |
| eeee | fff | NULL | NULL |
+------+-----+------+------+
```

### COMPACT行格式
![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1626440760040-07758ce0-2f0a-4fbc-a728-af25e30d80d2.png)

一条完整的记录分为记录的额外信息和记录的真实数据两部分。

#### 记录的额外信息
+ **变长字段长度列表**

如VARCHAR(M)、TEXT类型，他们存储多少字节的数据是不固定的，因此需要存储这些数据占用的字节数。变长字段占用的存储空间分为两部分：**真正的数据内容**和**占用的字节数**。

**固定长度字段（如CHAR(10)）占用的字节数也有可能存储在变长字段长度列表中！**

**各变长字段占用字节数**按照**倒序存放**。

| 列名 | 存储内容 | 内容长度（十进制） | 内容长度（十六进制） |
| --- | --- | --- | --- |
| c1 | 'aaaa' | 4 | 0x04 |
| c2 | 'bbb' | 3 | 0x03 |
| c4 | 'd' | 1 | 0x01 |


由于创建表时指定了字符集为`ascii`，故每个字符只需要1个字节来编码，又因为按照列的逆序存放，所以最后变长字段长度列表用十六进制表示的效果就是：`010304`

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1626441611109-6c8ddfaa-969d-489d-8e47-936c9f96baa7.png)

如果变长列的内容占用的字节数比较多，可能就需要用2个字节来表示。

假设某个字符集表示一个字符**最多需要使用的字节数为W**，也就是使用`SHOW CHARSET`语句的结果中的`Maxlen`列，比方说`utf8`中的W就是3，`GBK`的W是2，`ascii`的W是1。

对于变长类型VARCHAR(M)来说，**最多能存储M个字符。**

**则最多占用的字节数为**`**MxW**`。

假设**实际存储字符串**占用的字节数为**L**。

    - 当`MxW <= 255`时，使用1个字节来表示真正字符串占用的字节数

1个字节可以表示0 ～ 255，InnoDB在读取记录的变长字段长度列表时，会先查看表结构，如果某个变长字段允许存储的最大**字节数**不超过255，可以认为只使用1个字节来表示真正字符串占用的字节数。

    - 当`MxW > 255`时

同样的，如果InnoDB查看表结构发现某个变长字段允许存储的**字节数**超过255，则再根据下列条件做判断：

        * `L <= 127`，则用1个字节来表示真正字符串占用的字节数
        * `L > 127`，则用2个字节来表示真正字符串占用的字节数

即用第一个字节的第一个二进制位作为标志位，当第一位为0时，那么该字节就是一个单独的字段长度，除去符号位还有7位，能表示的数的范围为0 ～ 2<sup>7</sup>-1即0 ～ 127。

当第一位为1时，那么该字节和下一个字节是一个单独的字段长度。除去符号位还有15位，能表示的数的范围为0 ～ 2<sup>15</sup>-1即0 ～ 32K - 1。

InnoDB页默认大小为16KB，如果某个字段长度大于16KB，那么该记录在当前页面无法存储，InnoDB会把一部分数据放到溢出页中，变长字段列表中只存储留在本页面中的长度。

MySQL采取 Little Endian 的计数方式，低位在前，高位在后，所以 129 就是 10000001 10000000。

    - 变长字段列表只存储值为**非NULL**的列内容占用的长度，也就是对于例子中的第二条记录来说，只需要存储c1和c2列的长度即可。

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1626444621374-b9f5ebc6-f59e-40f7-9fa9-9dfc7d0c4660.png)

    - 上述例子中采用的字符集为`ascii`，每个字符占用1字节。当采用`GBK`（1～2字节）或者`utf8`（1～3字节）时，**对于CHAR(M)来说，字符数固定并不等于占用字节数固定。**因此也需要将其占用字节数存入变长字段长度列表。

当修改上述例子的表的字符集为`utf8`后，变长字段长度列表也发生了变化。

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1626490674185-b4227535-4adf-4daf-9b31-680c47a81f78.png)

    - 对于`CHAR(M)`，采用变长字符集时要求该列至少占用M的字节，即使存储一个空字符串，也会占用M个字节，将来更新该列的值的字节长度大于原有值的字节长度而小于M个字节时，可以直接在该记录处直接更新，而不用重新分配新的记录空间，导致原有的记录空间成为所谓的碎片。



+ **NULL值列表**
    1. 首先统计允许存储NULL的列有哪些

上述例子中，c1、c3、c4都允许为NULL，而c2不允许为NULL。

    2. 如果没有允许存储NULL的列，那么NULL值列表也不存在了。否则每个允许存储NULL的列对应一个二进制位，二进制位按照列的逆序排列，值为1时表示该列的值为NULL，值为0时不为NULL。
    3. NULL值列表必须用整数个字节的位表示，如果使用的二进制位个数不是整数个字节，则在**高位补0**

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1626445828215-a61d209b-3e03-4928-9b82-0e7a664d7278.png)

以此类推，如果一个表中有9个允许为NULL，则这个记录的NULL值列表部分就需要2个字节来表示。

对于上面的例子，第一条记录，c1、c3、c4都不为NULL，则表示为`0x00`；

第二条记录，c3、c4的值为NULL，则二进制表示为`00000110`，十六进制表示为`0x06`。

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1626445995215-64b49795-37db-4620-a396-df20901fe7e2.png)



+ **记录头信息（共5 Byte）**

| **名称** | **大小（bit）** | **描述** |
| --- | --- | --- |
| 预留位1 | 1 | 没有使用 |
| 预留位2 | 1 | 没有使用 |
| delete_mask | 1 | 标记该记录是否被删除 |
| min_rec_mask | 1 | B+树每层非叶子结点中的最小记录都会添加该标记 |
| n_owned | 4 | 表示当前记录拥有的记录数 |
| heap_no | 13 | 表示当前记录在记录堆的位置信息 |
| record_type | 3 | 记录类型，0为普通记录，1为B+树非叶子结点记录，2为最小记录，3为最大记录 |
| next_record | 16 | 表示下一条记录的相对位置 |


![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1626486870676-eaa4b70d-78bd-4152-aa57-0cc5eda752ab.png)

#### 记录的真实数据
MySQL会为每个记录添加额外的列（隐藏列），具体列如下：

| **列名** | **是否必须** | **占用空间** | **描述** |
| --- | --- | --- | --- |
| DB_ROW_ID | 否 | 7 字节 | 行ID，唯一标识一条记录 |
| DB_TRX_ID | 是 | 6 字节 | 事务ID，创建这条记录/最后一次更新这条记录的事务ID |
| DB_ROLL_PTR | 是 | 7 字节 | 回滚指针，指向这条记录的上一个版本 |


+ DB_ROW_ID

InnoDB优先使用用户自定义主键作为主键，如果用户没有定义主键，则选取一个Unique的键作为主键，如果也没有Unique键，则InnoDB会为表默认添加一个名为DB_ROW_ID的隐藏列作为主键。

+ DB_ROLL_PTR

DB_ROLL_PTR指向老记录形成的undo log。

+ 在上面的例子中，由于没有定义主键，所以MySQL会为每条记录增加上述的3个列。

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1626489509454-9abde05b-8044-4b15-bec1-d92a3686ad36.png)

+ 几个注意的点：
    1. 使用的是`ascii`字符集，所以`0x61616161`表示`aaaa`，`0x626262`表示`bbb`
    2. c3列是`CHAR(10)`类型的，存储字符串时只存储了2个字符`cc`，所以除真实数据外的8个字节统统用空格`0x20`补齐，结果为`0x63632020202020202020`
    3. 第二条记录中，c3和c4的值为NULL，他们已经记录在了NULL值列表处，故记录的真实数据处就不再冗余存储



### REDUNDANT行格式
MySQL 5.0之前用的一种行格式，5.0之后仍存在是为了兼容性。

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1626781437204-5c7a6049-737d-4589-9c54-84ee0eedaa29.png)

对于之前的例子，使用`Redundant`格式记录如下：

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1626781573019-6f807d2f-14c2-496c-bc01-d8c92959c675.png)

与`Compact`行格式的不同：

    - 字段长度偏移列表

`Compact`行格式开头是**变长字段长度列表**，而`Redundant`行格式的开头是**字段长度偏移列表**，字段长度偏移列表实质上是存储每个列中的值占用的空间在记录的真实数据处**结束**的位置。与变长字段长度列表有两处不同：

        * 没有了变长两字，意味着`Redundant`行格式会把该条记录中多有的列（包括3个隐藏列）的长度信息都按照逆序存储到字段长度偏移列表
        * 多了偏移两个字，`Redundant`行格式是采用两个相邻数值的差值来计算各个列值的长度

例如第1条记录的**字段长度偏移列表**为：`25 24 1A 17 13 0C 06`，因为按照逆序存放，所以按照列的顺序就是：`06 0C 13 17 1A 24 25`，按照两个相邻数值的差值来计算各个列值的长度的意思就是：

| 列名 | 计算式子 | 长度（Byte） |
| --- | --- | --- |
| DB_ROW_ID | 0x06 - 0x00 | 6 |
| DB_TRX_ID | 0x0C - 0X06 | 6 |
| DB_ROLL_PTR | 0x13 - 0x0C | 7 |
| c1 | 0x17 - 0x13 | 4 |
| c2 | 0x1A - 0x17 | 3 |
| c3 | 0x24 - 0x1A | 10 |
| c4 | 0x25 - 0x24 | 1 |


    - 记录头信息（共**6 Byte**，比`Compact`行格式多了1 Byte）

| **名称** | **大小（bit）** | **描述** |
| --- | --- | --- |
| 预留位1 | 1 | 没有使用 |
| 预留位2 | 1 | 没有使用 |
| delete_mask | 1 | 标记该记录是否被删除 |
| min_rec_mask | 1 | B+树每层非叶子结点中的最小记录都会添加该标记 |
| n_owned | 4 | 表示当前记录拥有的记录数 |
| heap_no | 13 | 表示当前记录在**页面堆**的位置信息 |
| n_field | 10 | 表示记录中列的数量（故最大列数为1023列） |
| 1byte_offs_flag | 1 | 标记字段长度偏移列表中每个列对应的偏移量是使用1字节还是2字节表示的 |
| next_record | 16 | 表示下一条记录的**绝对**位置 |


    - `1byte_offs_flag`的值是怎么选择的

记录的真实数据不大于127（十六进制`0x7F`，二进制`01111111`）时，每个列对应的偏移量占用1个字节。因为记录的真实数据都不大于127的时候，他们每个列对应的偏移量值肯定也不会大于127，用1字节表示就可以。

记录的真实数据占用字节数大于127，但不大于32767（十六进制`0x7FFF`，二进制`0111111111111111`）时，每个列对应的偏移量占用2个字节。

记录的真实数据大于32767时，记录存放到了溢出页，在本页中只保留前768字节和20字节的溢出页面地址（这20字节中还记录了一些别的信息）。因为字段长度偏移列表只记录每个列在本页面中的偏移，所以每个列使用2个字节存储偏移量就够了。

**当**`**1byte_offs_flag**`**的值为1时，表明使用1个字节存储，**

**当**`**1byte_offs_flag**`**的值为0时，表明使用2个字节存储。**

+ `Redundant`行格式中NULL值的处理

因为`Redundant`行格式并没有NULL值列表，所以设计`Redundant`行格式的大叔在字段长度偏移列表中的各个列对应的偏移量处做了一些特殊处理——将对应的**偏移量值的第一个比特位**作为是否为NULL的依据，该比特位也可以被称为NULL比特位。

解析一条记录的某个列时，先看一下该列对应的偏移量的NULL比特位是否为1，**如果为1，那么该列的值就是NULL。**

    - 如果存储NULL值的字段是定长类型的（如CHAR(M)），则NULL值也占用记录的真实数据部分，并用`0x00`字节填充，如上图第2条记录的c3列所示。
    - 如果存储NULL值的字段是变长数据类型的，则不在记录的真实数据处占用任何存储空间，如上图第2条记录的c4列所示。
+ `CHAR(M)`列的存储格式

`Compact`行格式在`CHAR(M)`类型的列中存储数据的时候分变长字符集和定长字符集的情况，而在`Redundant`行格式中不管该列使用的字符集是啥，只要是使用`CHAR(M)`类型，占用的真实数据空间就是该字符集表示一个字符最多需要的字节数和`M`的乘积。比方说使用`utf8`字符集的`CHAR(10)`类型的列占用的真实数据空间始终为30个字节，使用`gbk`字符集的`CHAR(10)`类型的列占用的真实数据空间始终为20个字节。由此可以看出来，使用Redundant行格式的CHAR(M)类型的列是**不会产生碎片**的。

### 行溢出数据
#### VARCHAR(M)最多能存储的数据
对于VARCHAR(M)最多可以存储65535字节，这65535字节包括3部分存储空间：真实数据、真实数据占用字节的长度和NULL值标识（允许为NULL时）。

在使用ascii字符集时，如果VARCHAR类型没有NOT NULL属性，则最多只能存储65532字节的数据，因为真实数据长度可能占用2字节，NULL值标识需要占用1字节。如果VARCHAR类型的列有NOT NULL属性，那最多只能存储65533个字节的数据，因为真实数据的长度可能占用2个字节，不需要NULL值标识。

如果VARCHAR(M)类型的列使用的不是ascii字符集，那M的最大取值取决于该字符集表示一个字符最多需要的字节数。在列的值允许为NULL的情况下，gbk字符集表示一个字符最多需要2个字节，那在该字符集下，M的最大取值就是32766（也就是：65532/2），也就是说最多能存储32766个字符；utf8字符集表示一个字符最多需要3个字节，那在该字符集下，M的最大取值就是21844，就是说最多能存储21844（也就是：65532/3）个字符。

**上述都是在表中只有一个字段的情况下说的，一个行中的所有列（不包括隐藏列和记录头信息）占用的字节长度加起来不能超过65535个字节。**

#### 记录中数据的溢出
例如VARCHAR(M)、TEXT和BLOB类型的列会发生行溢出。

在Compact和Redundant行格式中，在记录的真实数据处只会存储一部分数据（768字节），然后用20字节存储指向剩余数据存储的页的地址、以及这些数据占用的字节数。

每个页需要132字节存储页信息，每个页至少存放两条数据，每条记录需要额外的27字节的信息。所以有132 + 2 x (27 + n) < 16384，求得n < 8099，即一个列存储的数据小于8099字节，那么该列就不会成为溢出列（针对表中只有一个列的情况）。

#### Dynamic和Compressd行格式
和Compact格式基本相同，Dynamic格式在处理行溢出数据上是将所有字节存储到其他页面中，而Compressd还会采用压缩算法对页面进行压缩以节省空间。



## InnoDB数据页面结构
页是InnoDB管理存储空间的基本单位，大小一般是16KB，InnoDB有很多种页，其中数据页（索引页）的结构如下：

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1627733502157-cc77a2ef-ab55-416c-8b12-0fd8f75da142.png)

### 记录在页中的存储（User Records）
记录会按照指定的行格式存储到User Records中，在页刚生成时，并没有User Records部分，每当插入一条记录，都会从Free Space部分申请一个记录大小的空间划分到User Records中，当Free Space部分全部被User Records替代之后，如果还有新纪录插入的话就需要申请新的页。

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1627733790978-6aa59ddc-804f-42f3-80b8-e02aa2eb0bb5.png)

+ 行记录头信息
    - delete_mask

值为0表示记录没有被删除，值为1表示记录已被删除。

被删除的记录仍然在页中，被删除的记录会组成一个垃圾链表，这个链表中的记录占用的空间称之为可重用空间，之后如果有新记录插入到表中的话，可能把这些被删除的记录占用的存储空间覆盖掉。

    - min_rec_mask

B+树的每层非叶子节点中的最小记录都会添加该标记，为0时表示不是B+树中非叶子节点中的最小记录。

    - n_owned

表示该记录拥有多少条记录，即组内共有多少条记录，见页目录。

    - heap_no

当前记录在页中的位置。每个页中都会有两条记录，一条为最小记录，一条为最大记录，他们的heap_no分别为0和1。对于一条完整的记录来说，比较记录的大小就是比较主键的大小。

    - record_type

0表示普通记录，1表示B+树非叶子节点记录，2表示最小记录，3表示最大记录。

    - next_record

当前记录的**真实数据**到下一条记录的真实数据的地址偏移量（有可能小于0）。比方说第一条记录的next_record值为32，则从第一条记录的真实数据地址向后找32个字节便是下一条记录的真实数据。

下一条记录并不是指按照我们插入顺序的下一条记录，而是按照主键值从小到大的顺序的下一条记录，并且规定Infimum记录（最小记录）的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是Supermum记录（最大记录）。

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1627800103948-a67c71e9-3f00-4b7f-b425-48d29c908874.png)

最大记录的next_record值为0，即最大记录没有下一条记录了。删除掉一条记录，链表也会跟着变化：

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1627800163567-71d61625-f69c-4f11-89f5-7f81014cf754.png)

从图中可以看到，删除第2条记录前后发生了这些变化：

        * 第2条记录并没有从存储空间中移除，而delete_mask变为1
        * 第2条记录的next_record变为0，意味着该记录没有下一条记录了
        * 第1条记录的next_record指向了第3条记录
        * 最大记录的n_owned从5变为了4
    - 重新插入第2条记录后，并不会申请新的存储空间，而是直接复用了原来被删除记录的存储空间

### 页目录（Page Directory）
+ 页目录制作过程：
    1. 将所有正常的记录（最小、最大记录，不包括标记为已删除的记录）划分为几个组
    2. 每个组的最后一条记录（组内最大记录的头信息中的n_owned属性表示该记录拥有多少条记录，即组内共有几条记录）
    3. 每个组的最后一条记录的地址偏移量单独提取出来按顺序存储到**靠近页尾部**的地方，这个地方就是页目录。页目录中的这些地址偏移量被称为槽，所以这个页面目录就是由槽组成的。
+ 注意最小记录和最大记录的头信息的n_owned属性
    - 最小记录的n_owned为1，表示这个分组中只有1条记录
    - 最大记录的n_owned为5，表示这个分组中只有5条记录

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1627955260675-abc937c7-dba9-4faa-9245-15a01c0d877a.png)

+ 对于分组中记录数量的规定
    - 最小记录的分组只能有1条记录
    - 最大记录所在的分组记录数在1~8条之间
    - 剩下的分组中记录的条数范围只能在4~8条之间

分组按照以下步骤进行：

    1. 初始情况下一个数据页里只有最小记录和最大记录两条记录，分别属于两个分组
    2. 之后每插入一条记录，都会从页目录中找到主键值比本记录大并且差值最小的槽，然后把该槽对应的n_owned加1，表示组内又添加了一条记录，直到该组中的记录数等于8个
    3. 在一个组中的记录数等于8个后再插入一条记录时，会将组中的记录拆分成两个组，一个组中4条记录，另一个5条记录。这个过程会在页目录中新增一个槽来记录这个新增分组中最大的那条记录的偏移量
+ 在一个数据页中查找指定主键值的记录的过程
    1. 通过**二分法**确定该记录所在的槽，并找到该槽所在分组中主键值最小的那条记录
    2. 通过记录的next_record遍历该槽所在的组中的各条记录

### 页面头部（Page Header）
记录数据页存储的记录的状态信息，占用56字节。

+ **PAGE_N_DIR_SLOTS**  2字节

在页目录中的槽数量

+ **PAGE_HEAP_TOP**  2字节

还未使用的空间的最小地址，也就是说从该地址之后就是Free Space

+ **PAGE_N_HEAP**  2字节

在页中的记录数量（包括了最小记录和最大记录以及标记为删除的记录）

+ **PAGE_FREE**  2字节

第一个已经标记为删除的记录地址（各个已删除的记录通过next_record也会组成一个单链表，这个单链表中的记录空间可以被重新利用）

+ PAGE_GARBAGE  2字节

已删除记录占用的字节数

+ PAGE_LAST_INSERT  2字节

最后插入记录的位置

+ PAGE_DIRECTION  2字节

记录插入的方向

假如新插入的一条记录的主键值比上一条记录的主键值大，则认为插入方向是右边，反之是左边。

+ PAGE_N_DIRECTION  2字节

一个方向连续插入的记录数量

假设连续几次插入新记录的方向都是一致的，InnoDB会把沿着同一个方向插入记录的条数记下来，如果最后一条记录的插入方向改变了，则这个状态会清零。

+ PAGE_N_RECS  2字节

该页中的记录数量（不包括最小记录和最大记录以及被标记为删除的记录）

+ PAGE_MAX_TRX_ID  8字节

修改当前页的最大事务ID，该值仅在二级索引中定义

+ PAGE_LEVEL  2字节

当前页在B+树中所处的层级

+ PAGE_INDEX_ID  8字节

索引ID，表示当前页属于哪个索引

+ PAGE_BTR_SEG_LEAF  10字节

B+树叶子段的头部信息，仅在B+树的Root页定义

+ PAGE_BTR_SEG_TOP  10字节

B+树非叶子段的头部信息，仅在B+树的Root页定义

### 文件头部（File Header）
不同类型的页都会以File Header作为第一个组成部分，这个部分占用固定的38个字节。

+ FIL_PAGE_SPACE_OR_CHKSUM  4字节

页的校验和（checksum值）

+ FIL_PAGE_OFFSET  4字节

页号，InnoDB可以通过页号定位1个页。

+ FIL_PAGE_PREV  4字节

上一页的页号

+ FIL_PAGE_NEXT  4字节

下一页的页号

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1627957121035-6e8a51ac-426e-4414-909a-b2b7aacde356.png)

+ FIL_PAGE_LSN  8字节

页面被最后修改时对应的日志序列位置（Log Sequence Number）

+ FIL_PAGE_TYPE  2字节

页的类型

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1627957068433-0cac8971-139a-4c36-b640-e6d88eb5f9a7.png)

+ FIL_PAGE_FILE_FLUSH_LSN  8字节

仅在系统表空间的一个页中的定义，代表文件至少被刷新到了对应的LSN值

+ FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID  4字节

页属于哪个表空间

### File Trailer
8个字节，分为两部分：

+ 前4个字节代表页的校验和

这个部分是和**File Header中的校验和**相对应的。每当一个页面在内存中修改了，在同步之前就要把它的校验和算出来，因为File Header在页面的前边，所以校验和会被首先同步到磁盘，当完全写完时，校验和也会被写到页的尾部，如果完全同步成功，则页的首部和尾部的校验和应该是一致的。如果写了一半儿断电了，那么在File Header中的校验和就代表着已经修改过的页，而在File Trailer中的校验和代表着原先的页，**二者不同**则意味着同步中间出了错。

+ 后4个字节代表页面被最后修改时对应的日志序列位置（Log Sequence Number）

也是为了校验页的完整性。

---

## B+树索引
### 没有索引的查找
+ 在一个页中查找
    - 以主键为条件

在页目录中使用二分法快速定位到对应的槽，<font style="color:rgb(51, 51, 51);">然后再遍历该槽对应分组中的记录即可快速找到指定的记录。</font>

    - <font style="color:rgb(51, 51, 51);">以其他列作为搜索条件</font>

无法在页目录中定位到对应的槽，只能从**最小记录**开始沿着`next_record`遍历每一条记录看是否匹配。

+ 在多个页中查找

1、定位到记录所在的页

2、从所在的页内查找相应的记录

由于无法确定数据所在的页，所以只能从第一个页开始<font style="color:rgb(51, 51, 51);">沿着双向链表一直往下找，在每个页中使用上述方式查找记录。</font>

### 假设的索引方案
在页中，页目录是根据主键值快速定位一条记录在页中的位置而设立的。类似的，也可以为快速定位记录所在的数据页而建立一个别的目录，对这个目录的要求有：

1. 下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值
2. 给所有的页建立一个目录项



+ 假设现在有一个页，页10，并且假设一个页只能存3条记录**（是假设是假设是假设）**

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1633597612526-8188845b-40cd-4f4e-97be-44e6ac4d501e.png)

再插入一条记录，`INSERT INTO index_demo VALUES(4, 4, 'a');`，则需要再分配一个新页

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1633597684911-6152fe77-933f-463b-b3cb-9fb276aee125.png)

此时页28中的记录主键值4小于页10中的最大的主键值5，故不符合“下一个数据页中用户记录的主键值必须大于上一个页中用户记录的主键值的要求”。

所以需要进行**页分裂**操作，即将主键5的记录移动到页28中，将主键4的记录移动到页10中，来保持下一个数据页中用户记录的主键值大于上一页中用户记录的主键值这一状态。

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1633850491048-762a47d8-78ef-4fa1-977b-05d120620e9d.png)

+ 给所有的页建立一个目录项

由于数据页的编号可能不是连续的，而且这些16KB的页在物理存储上可能也并不连续，所以想根据主键值快速定位某些记录所在的页，就需要给这些页再做一个目录，每个页对应一个目录项，每个目录项包括以下两个部分：

    - 页的用户记录中最小的主键值
    - 页号

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1633850687374-3d650849-6524-4dc1-b06c-cbe8de377fe5.png)

此时，如果想查找主键值为20的记录，具体步骤为：

    1. 先从目录项中根据二分法快速确定出主键值为20的记录在目录项3中（12 < 20 < 209），对应页9
    2. 再根据前面在页中查找记录的方式去页9中定位具体的记录

### InnoDB的索引方案
+ 上述简易方案的不合理之处
    - 目录项的存储空间连续，而记录数量增多时，就需要非常大的连续存储空间才能存放所有的目录项了，这是不现实的
    - 记录有可能被删除，假设某个页中的记录都被删除，则这一页也没有存在的必要了，此时这一页对应的目录项也就没有存在的必要，又因为目录项的存储空间连续，删除目录项就需要将其之后的目录项全都向前移动一个单位
+ 目录项其实跟用户记录长得差不多，只不过目录项的两个列是**主键**和**页号**，因此可以复用数据页来存储目录项，在记录上作区分就可以（记录头的record_type属性，0表示用户记录，1表示目录项记录，2表示最小记录，3表示最大记录）

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1633851337758-946489f2-59ed-4354-92a6-009d1ff7f913.png)

+ 总结**目录项记录**和**用户记录**的差异
    - 目录项记录的record_type是1，用户记录的record_type是0
    - 目录项记录只有主键值和页号两列，用户记录的列由用户自定义，还有InnoDB添加的隐藏列
    - 在存储目录项记录的页中，主键最小的那一条目录项记录的min_rec_mask为1，其他目录项记录和用户记录的min_rec_mask都为0
+ 总结**目录项记录**和**用户记录**的相同点
    - 用的都是一样的数据页（0x45BF）
    - 都会为主键值生成页目录Page Directory
    - 在页中都可以根据主键值进行二分查找（因为有页目录）
+ 例子：查找主键为20的记录
    - 先到存储目录项记录的页，也就是页30，通过二分法快速定位对应的目录项记录，因为12 < 20 < 209，所以定位到对应的记录所在的页就是页9
    - 再到页9中根据二分法快速定位到主键值为20的用户记录
+ 上述情况为目录项记录只有一个页的情况，但是一个页只有16KB大小，如果表中数据太多，一个数据页不足以存放所有的目录项记录，这时候就需要创建一个新的页来存储新的目录项

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1633851949824-867ae2c8-0c4e-45e9-95a5-9b4e69c441b0.png)

而存放目录项的页在存储空间上页可能不挨着，如果表中的数据非常多则会产生很多存储目录项记录的页，此时就需要为这些页生成一个更高级的目录。

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1633852118340-b07747bd-c142-469f-afca-e94c3d3caf9d.png)

+ 不论是存放用户记录的数据页，还是存放目录项记录的数据页，都存放到B+树这个数据结构中了
    - 实际用户记录都存放在B+树的最底层的节点上，也就是叶子节点
    - 目录项记录都存放在非叶子节点，最上面的节点称为根节点

### 聚簇索引
上面介绍的B+树本身就是一个索引，它有两个特点：

1. 使用记录**主键值的大小顺序**进行记录和页的排序
    1. 页内的记录按照**主键的大小顺序**排成一个单向链表
    2. 各个存放用户记录的页也是根据页中用户记录的**主键大小顺序**排成一个双向链表
    3. 在同一层的存放目录项记录的页也是根据**主键大小顺序**排成一个双向链表
2. B+树叶子节点存储的是完整的用户记录

也就是说这个记录中存储了所有列的值（包括隐藏列）

+ 我们把具有这两种特性的B+树称为聚簇索引，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。这种聚簇索引并不需要使用INDEX语句去创建，InnoDB存储引擎会自动的为我们创建聚簇索引。
+ 在InnoDB引擎中，聚簇索引就是数据的存储方式（所有的用户记录都存放在了叶子节点，索引即数据，数据即索引）

### 二级索引
聚簇索引只能在**搜索条件是主键值**时才能发挥作用，因为B+树中的数据都是按照**主键**进行排序的。

假设以c2列的大小作为数据页、页中记录的排序规则，再建一颗B+树，效果如下：

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1633852967295-9e48cf11-deba-42f8-acbf-6e41a42229d5.png)

这个B+树与聚簇索引的不同：

+ 使用记录c2列的大小进行排序
    - 页内的记录按照c2列的大小顺序排序成一个单向链表
    - 存放用户记录的页也根据c2列的大小顺序排成一个双向链表
    - 同一层的存放目录项记录的页也根据c2列的大小顺序排序成一个双向链表
+ B+树的叶子节点不存储完整的用户记录，只存储**c2列**和**主键**两个列的值
+ 目录项记录不是主键和页号的搭配，而是**c2列**和**页号（其实还有主键值）**的搭配

假设现在查找c2列的值为4的记录，查找过程如下：

1. 确定目录项记录页

在根页面中，由于2 < 4 < 9，定位到目录项记录所在的页是页42

2. 通过**目录项记录页**确定**用户记录所在的页**

由于c2列没有唯一性约束，所以以c2列值为4的记录可能存在于多个数据页中，因为2 < 4 <= 4，因此实际存储用户记录的页在页34和页35中

3. 在用户记录页中定位具体的记录

根据页目录二分定位

4. 但是这个B+树的叶子节点中的记录只存储了**c2和主键**两个列的值，所以必须根据主键值去聚簇索引中在查找一遍完整的用户记录（这个过程也就是**回表**）
+ 根据c2列查询一条完整的用户记录需要使用到两棵B+树，因此这种索引也称为二级索引

### 联合索引
同时以多个列的大小作为排序规则建立索引，比如按照c2列和c3列的大小进行排序：

+ 先把各个记录和页按照c2列进行排序
+ 在记录的c2列相同的情况下，采用c3列进行排序

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1633853637119-7781f57a-de04-4d78-8a6d-30bfe4c3935f.png)

+ 每条目录项记录都由c2、c3和页号（其实还有主键值）三个部分组成，各条记录先按照c2列的值进行排序，如果记录的c2列相同，则按照c3列的值进行排序
+ B+树的叶子节点处的用户记录由c2、c3和主键三个列组成
+ 联合索引本质上也是一个二级索引（查询完整记录需要回表），它与分别为c2和c3列建立索引是不同的
    - 建立联合索引只会建立1棵B+树，而分别为c2和c3列建立索引会建立2棵B+树

### InnoDB的B+树索引的注意事项
#### 根页面万年不动
+ 每当为某个表创建一个B+树索引（聚簇索引不是认为创建的，默认就有）的时候，都会为这个索引创建一个根节点页面。最开始表中没有数据的时候，每个B+树索引对应的根节点既没有用户记录，也没有目录项记录
+ 随后向表中插入用户记录时，先把用户记录存储到这个根节点中
+ 当根节点中的可用空间用完时继续插入记录，此时会将根节点中所有的记录复制到一个新的分配页，比如页a中，然后对这个新页进行页分裂操作，得到另一个新页，如页b。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小被分配到页a或页b中，根节点便升级为存储目录项记录的页
+ 一个B+树索引的根节点自诞生之日起，便不会再移动。这样只要我们对某个表建立一个索引，那么它的根节点的页号便会被记录到某个地方，然后凡是InnoDB存储引擎需要用到这个索引的时候，都会从那个固定的地方取出根节点的页号，从而来访问这个索引。

#### 非叶子节点中目录项记录的唯一性
B+树内节点中目录项记录的内容是**索引列**和**页号**的搭配，但是这个搭配对于二级索引并不严谨。

假设有这样一个表：

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1633855650571-bf4d3264-65ec-4f3e-b213-c52af9e0f067.png)

+ 为c2列建立索引，如下图

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1633855667142-9717a044-cd61-4cd8-adb2-aaaa5691e1f0.png)

+ 假如这时插入一条新记录，c1、c2、c3的值分别是 9、1、‘c’，那么在修改这个二级索引对应的B+树时便会有一个问题，由于页3中存储的目录项记录是由c2列和页号构成的，而页3两条目录项记录对应的c2列的值都是1，这时候新插入的记录的c2列的值也是1，那么新插入的记录应该放到页4还是页5？
+ 为了能让新插入记录找到自己在哪个页里，我们需要保证在B+树的**同一层内**节点的目录项记录除了**页号**这个字段以外是唯一的，因此对于二级索引的内节点的目录项记录的内容实际上由三部分构成：
    - 索引列的值
    - 主键值
    - 页号

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1633855901160-ffaa32f8-8876-4321-a73b-4d8e4adfb7ef.png)

+ 这样我们再插入记录(9, 1, 'c')时，由于页3中存储的目录项记录是由c2列、主键、页号的值构成的，可以**先把新记录的c2列的值和页3中各目录项记录的c2列的值做比较**，如果c2列的值相同的话，可以**接着比较主键值**，因为B+树同一层中不同目录项记录的c2+主键的值肯定不一样，最后肯定能定位唯一的目录项记录

### MyISAM的索引方案
InnoDB索引即数据，而MyISAM将索引和数据分开存储

+ MyISAM将表中记录按照**插入顺序**单独存储在一个文件中，称之为数据文件。这个文件不划分数据页，有多少记录就存多少记录，可以通过**行号**快速访问到一条记录。
+ 由于在插入数据的时候并没有按照主键大小排序，所以并不能在这些数据上使用二分法进行查找

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1633856725660-87d37578-a031-4f28-947c-1cc30092a88e.png)

+ MyISAM把索引信息另外存储到一个**索引文件**。MyISAM会单独为表的主键创建一个索引，索引的叶子节点中存储的不是用户的完整记录，而是**主键值**和**行号**的组合，也就是先通过索引找到对应的行号，再通过行号去找对应的记录
+ 这一点和InnoDB时完全不同的，InnoDB中根据主键值对聚簇索引进行一次查找就能找到对应的记录，而MyISAM还需要多一次回表操作，意味着**MyISAM中建立的所有索引都是二级索引**
+ 对其他列建立索引或联合索引，原理和InnoDB的索引差不多，只不过叶子节点存储的是**索引列**和**行号**的搭配，并且这些索引都是二级索引
+ MyISAM的行格式有定长记录格式（Static）、变长记录格式（Dynamic）、压缩记录格式（Compressed）
    - 定长记录格式：一条记录占用空间固定，可以轻松算出某条记录在数据文件中的地址偏移量
    - 变长记录格式：在索引的**叶子**节点处记录该记录在数据文件中的地址偏移量

MyISAM的回表操作是非常快速的，因为是拿着地址偏移量直接到文件中读取数据，而InnoDB是通过获取主键后再去聚簇索引里找记录，速度还是比不上直接用地址去访问。

## B+树索引的使用
### 索引的代价
+ 空间上的代价

每建立一个索引都要为它建立一棵B+树，每一棵B+树的每一个节点都是一个数据页，一个页默认占用16KB的存储空间，一棵很大的B+树由许多数据页组成。

+ 时间上的代价

每次对表中的数据进行增、删、改操作时，都需要去修改各个B+树索引。**B+树每层节点**都是按照索引列的值从小到大的顺序排序而组成了**双向链表**。

不论是用户记录还是目录项记录，都是按照索引列的值从小到大的顺序形成的**单向链表**。而增、删、改操作可能会对节点和记录的排序造成破坏，所以存储引擎需要额外的时间进行一些**记录移位**，**页面分裂**，**页面回收**等操作来维护好节点和记录的排序。

### B+树索引适用的条件
B+树索引不是万能的，并不是所有的查询语句都能用到建立的索引。

+ 举个例子，建一张表

```sql
CREATE TABLE person_info(
    id INT NOT NULL auto_increment,
    name VARCHAR(100) NOT NULL,
    birthday DATE NOT NULL,
    phone_number CHAR(11) NOT NULL,
    country varchar(100) NOT NULL,
    PRIMARY KEY (id),
    KEY idx_name_birthday_phone_number (name, birthday, phone_number)
);
```

+ 其中索引`idx_name_birthday_phone_number`如下图

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1633877970999-b3d8acd2-e209-4b81-a0b9-f616fa48e6c6.png)

#### 全值匹配（搜索条件与索引列一致）
`SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27' AND phone_number = '15123983239';`

    - B+树的数据页和记录是先按照name列值进行排序的，可以很快定位name列的值是`Ashburn`的记录位置
    - 在name列相同的记录里又是按照birthday列的值排序的，所以又可以很快定位birthday列的值是`1990-09-27`的记录
    - 在name和birthday列值相同时，记录是按照phone_number列排序的
    - 如果调换name、birthday、phone_number几个列的顺序，对查询的结果没有影响，MySQL有**查询优化器**

#### 匹配左边的列
`SELECT * FROM person_info WHERE name = 'Ashburn';`

`SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1990-09-27';`

以上两个语句是可以使用`idx_name_birthday_phone_number`这个索引的，但是下面的语句不行：

`SELECT * FROM person_info WHERE birthday = '1990-09-27';`

因为B+树的数据页和记录是先按照name列的值排序的，在name列的值相同的情况下才用birthday列进行排序，也就是说，**name列的值不同的记录中birthday的值可能是无序的**。

#### 部分匹配
`SELECT * FROM person_info WHERE name = 'Ashburn' AND phone_number = '15123983239';`

上面这个语句只能使用name列的索引，birthday和phone_number的索引用不上

#### 匹配列前缀（例子：URL）
对于字符串的排序，先按照第一个字符进行排序，如果第一个字符相同再按照第二个字符排序，以此类推。

也就是说这些字符串的前n个字符，也就是前缀，都是排好序的，所以对于字符串类型的索引列来说，我们**只匹配它的前缀也是可以快速定位记录（使用索引）的**，比如说查询名字以As开头的记录：

`SELECT * FROM person_info WHERE name LIKE 'As%';`

但需要注意的是，如果只给出后缀或者中间的某个字符串，比如这样：

`SELECT * FROM person_info WHERE name LIKE '%As%';`

MySQL就无法快速定位记录的位置了，因为**中间有As的字符串并没有排好序**，所以只能**全表扫描**。

    - 例子：

假设已经对该url列创建了索引，如果我们想查询**以com为后缀**的网址的话可以这样写查询条件：`WHERE url LIKE '%com'`，但是这样的话**无法使用该url列的索引**。为了在查询时用到这个索引而不至于全表扫描，我们可以**把后缀查询改写成前缀查询**，不过我们就得把表中的**数据全部逆序存储**一下，也就是说我们可以这样保存url列中的数据：

```plain
+----------------+
| url            |
+----------------+
| moc.udiab.www  |
| moc.elgoog.www |
| nc.vog.www     |
| ...            |
| gro.otw.www    |
+----------------+
```

这样再查找以com为后缀的网址时搜索条件便可以这么写：`WHERE url LIKE 'moc%'`，这样就可以用到索引了。

#### 匹配范围值（或精确匹配某一列并范围匹配另外一列）
`SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';`

由于B+树中的数据页和记录是先按name列排序的，所以查询过程是：

    - 通过B+树在叶子节点找到第一条name值大于Asa的二级索引记录，读取该记录的主键值进行回表操作，获得对应聚簇索引记录后发送给客户端
    - 根据上一步找到的记录，沿着记录所在的链表向后查找（同一页面中的记录使用单向链表链接，数据页之间使用双向链表链接）下一条二级索引记录，判断该记录是否符合`name < ‘Barlow’`的条件，如果符合，则进行回表操作后发送给客户端
    - 重复上一步骤，直到某条二级索引记录不符合`name < ‘Barlow’`的条件为止  

 

在使用**联合索引**进行**范围查找**时，只有对**第一个范围查找的列生效**，且此列后面的条件不走索引：

比如这样是走索引的：

`SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow'`

`SELECT * FROM person_info WHERE name = 'Asa' AND birthday > '1980-01-01'`

但是下面这样是**不走索引（不完全走）**的：

`SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' AND birthday > '1980-01-01';`

`SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' AND birthday = '1980-01-01';`

此时name列的范围查询会使用到联合索引，但是用不到该索引birthday列的部分，因为这个索引只有name值相同的情况下才用birthday列的值排序，而根据name列范围查询出来的记录可能name列并不相同，所以birthday列可能是乱序的，所以在搜索条件中继续以birthday列进行查找时是用不到这个B+树索引的。  

 

`SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday > '1980-01-01' AND birthday < '2000-12-31' AND phone_number > '15100000000';`

这个查询可以分为3个部分：

    1. name = 'Ashburn'，对name列进行精确查找，可以使用索引
    2. birthday的范围查询，由于name列精确查找，所以查找后的记录的name值都是相同的，它们会按照birthday的值在进行排序，所以对birthday列的范围查找是可以用到B+树索引的
    3. phone_number > '15100000000'，通过birthday范围查找的记录的birthday值可能不同，所以这个条件无法再利用B+树索引了，只能遍历上一步查询得到的记录

 

`SELECT * FROM person_info WHERE name = 'Ashburn' AND birthday = '1980-01-01' AND phone_number > '15100000000';`

这个查询可以使用整个索引

#### 用于排序
+ 一般情况下，会把记录加载到内存中再利用排序算法进行排序，如果结果集太大甚至可能会借助磁盘存放中间结果，这个过程称为**文件排序**。
+ 如果ORDER BY子句里用到了索引列，就有可能省去在内存或文件中排序的步骤

`SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;`

上述索引就是按照这个规则建立的，所以直接从索引中提取主键然后进行回表操作取出列就可以了。



`SELECT * FROM person_info ORDER BY phone_number, birthday, name LIMIT 10;`

不能使用索引，因为phone_number在name和birthday不同的情况下可能是无序的。



`SELECT * FROM person_info WHERE name = 'A' ORDER BY birthday, phone_number LIMIT 10;`

<font style="color:rgb(51, 51, 51);">可以使用索引，因为name列是精确匹配，在name列相同的情况下就是按照birthday列和phont_number列来进行排序的。</font>

+ **不可以使用索引进行排序的几种情况**
    - **ASC、DESC混用**

对于使用联合索引进行排序的场景，要求各个排序列的顺序一致，要么各个列都是ASC、要么都是DESC

原因：因为索引全都是按升序排列，即先按name列升序排序，name列相同的时候再按birthday列升序排序，birthday列相同的情况再按phone_number列升序排序

如果查询中各个排序列的顺序一致，比如说以下两种情况：

`ORDER BY name, birthday LIMIT 10`

`ORDER BY name DESC, birthday DESC LIMIT 10`

第一种情况从索引最左边往右读10行记录，第二种情况从索引最右边往左读10行记录



`SELECT * FROM person_info ORDER BY name, birthday DESC LIMIT 10;`

**假设 假设 假设 **使用索引的话是这样的：

    1. 先从索引最左边确定name列最小的值，然后找到name列等于该值的所有记录，然后从name列等于该值的**最右边**的那条记录开始往左找10条记录
    2. 如果不足10条，再继续往右找name值第二小的记录，重复上述过程

并**不是不能使用索引，而是效率不够高**，所以这种情况会直接进行**文件排序**，所以MySQL规定了使用联合索引的各个排序列排序顺序必须一致。

    - 排序列包含非同一个索引的列
    - 排序列使用了复杂的表达式，如`ORDER BY UPPER(name)`

#### 用于分组
`SELECT name, birthday, phone_number, COUNT(*) FROM person_info GROUP BY name, birthday, phone_number`

    1. 先按照name值分组
    2. 在name值相同的分组里，在按照birthday分组
    3. 在name值和birthday值相同的分组里，在按照phone_number进行分组
    4. 然后针对每一个分组进行统计
+ 注意点
    - 分组列的顺序也需要和索引列的顺序一致
    - 也可以只使用索引列中左边的列进行分组

### 回表的代价
`SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow';`

使用索引后查询步骤：

    1. 从索引中取出name值在Asa～Barlow之间的用户记录
    2. 由于索引值只包含name、birthday、phone_number、id这4个字段，而查询列表是*，意味着要查询表中的所有字段，也就是还要包括country字段，这是需要把上一步中获取到的每一条记录的id都到聚簇索引对应的B+树中找到完整的用户记录，也就是回表，然后再把完整的用户记录返回给查询用户

在这个过程中，二级索引中name列的值是顺序排列的，所以在磁盘中的存储是相连的，这种读取方式称为**顺序I/O**，而根据id字段到聚簇索引中访问的完整的用户记录可能分布在不同的数据页中，这种读取方式是**随机I/O**，一般情况下顺序I/O的性能比随机I/O高很多。

    - 总结：
        * 使用两个索引，一个二级索引，一个聚簇索引
        * 访问二级索引使用顺序I/O（页内，页的存储是分散的，页外也是随机I/O），访问聚簇索引使用随机I/O
+ 需要回表的记录越多，上述方式查询的效率就越低

比如name值在Asa～Barlow之间的用户记录数量占全部记录数量90%以上，那么如果使用这个索引的话，有90%的id需要回表，这样还**不如直接扫描聚簇索引（全表扫描）**

+ MySQL的**查询优化器**会先对表中的记录计算一些统计数据，再利用这些统计数据计算需要回表的记录数，**需要回表的记录越多，就越倾向于使用全表扫描，反之使用二级索引+回表的方式**
+ 回表的记录越少，性能提升越高

`SELECT * FROM person_info WHERE name > 'Asa' AND name < 'Barlow' LIMIT 10;`

添加了`LIMIT 10`的查询**更容易**让优化器采用二级索引+回表的方式进行查询

+ **对于有排序需求的查询**

`SELECT * FROM person_info ORDER BY name, birthday, phone_number;`

由于查询列表是*，所以使用二级索引进行排序的话还需要把排序完的二级索引记录全部进行回表操作，这样的成本还不如直接遍历聚簇索引然后再进行文件排序，所以优化器会倾向于使用全表扫描的方式进行查询

`SELECT * FROM person_info ORDER BY name, birthday, phone_number LIMIT 10;`

这样需要回表的记录比较少，优化器就会倾向于使用二级索引+回表的方式进行查询

### 覆盖索引
如果在查询列表里只包含索引列，就不用回表

`SELECT name, birthday, phone_number FROM person_info WHERE name > 'Asa' AND name < 'Barlow'`

因为只查询name、birthday、phone_number这三个索引列的值，因此不必再到聚簇索引中查找完整记录

`SELECT name, birthday, phone_number  FROM person_info ORDER BY name, birthday, phone_number;`

虽然这个查询中没有LIMIT子句，但是采用了覆盖索引，所以优化器会倾向于直接使用二级索引进行排序，也不需要进行回表操作。

### 索引下推
一个表 t1(id, name, age)，有索引 (name, age)

SQL：SELECT * FROM t1 WHERE name like '陈%' AND age = 20;

没有索引下推：在存储引擎查 name like '陈%' 的，然后回表，然后在 MySQL 服务器过滤出 age = 20 的

有索引下推：在存储引擎查 name like '陈%' 的，查的过程中注意 age = 20 这个条件，然后回表，然后返回数据给 MySQL 服务器

区别：age = 20 这个条件下推到存储引擎进行判断

收益：在存储引擎判断 age = 20，可能可以减少查出来的数据数量，减少回表次数

+ 总结：将一部分判断条件下推到存储引擎进行判断，减少回表次数和返回给 MySQL 服务器的数据量

### 如何挑选索引
+ 为搜索、排序或分组的列创建索引
+ 考虑列的基数

列的基数指某一列中不重复数据的个数，列的基数如果为1，也就是所有记录在该列中的值都一样，那为该列建立索引是没有用的，因为**所有值都一样就无法排序**，也无法进行快速查找了。

而且如果索引的某个列的重复值特别多，那么使用这个索引查出的记录在回表操作时性能损耗会更大

+ 索引列的类型尽量小
    - 数据类型越小，查询时进行的比较操作越快
    - 数据类型越小，索引占用的存储空间越少，在一个数据页内就可以放下更多的记录（特别是主键，除了聚簇索引存储主键值，其他所有的二级索引的**每一个节点**也会存储记录的主键值，更小的数据类型意味着节省更多的存储空间和更高效的I/O）
+ **索引字符串值的前缀**
    - 索引完整字符串会占用更多的空间，在比较时会占用更多的时间

### 主键插入顺序
+ 假如插入记录的主键值依次增大，每插满一个数据页就换到下一个数据页继续插
+ 如果插入的主键值忽大忽小，则有可能需要进行**页面分裂**和**记录移位**
    - 因此建议让主键列拥有AUTO_INCREMENT属性

### 注意冗余和重复索引
+ 不要给主键列定义唯一索引和普通索引
+ 如果某一列已经是某个联合索引中的最左列，则没有必要为其定义索引

## 全文索引
在 MyISAM 和 InnoDB 引擎中有实现，基于倒排索引实现，默认支持英文（英文通过空格进行分词，支持中文需要额外的分词器）

+ 类型
    - 倒排文档索引：存储 (单词, 文档 id)
    - 完全倒排索引：存储（单词, {文档 id, 单词在文档中的位置}）
+ 在 InnoDB 中，采用完全倒排索引，内容存储在 6 张辅助表中，增加查询的并行度，6 张表根据单词进行分区
+ 全文索引存储在磁盘中，因此为了提高效率，InnoDB 在内存中建立了全文检索索引缓存，是一个红黑树结构，根据单词、文档 id、单词在文档中的位置进行排序
+ stopwords：存储不需要索引的单词（例如 the is are 之类的常见的单词）
+ 每张表只能有一个全文索引（全文索引可以是联合索引）

## InnoDB的表空间
+ 表空间的每一个页都对应着一个页号，也就是FIL_PAGE_OFFSET，这个页号由4个字节组成，也就是一个表空间可以有2的32次方个页，按照页的默认大小16KB来算，**一个表空间最多支持64TB数据**

### 独立表空间结构
+ 区（extent）的概念
    - 64个页（16KB）就是一个区，也就是说一个区默认占用**1MB**空间
    - 一个区就是在物理位置上连续的64个页，在表中数据量大的时候，为了某个索引分配空间的时候就不再按照页为单位分配了，而是按照区为单位分配（减少随机I/O）
    - **每256个区划分成一个组**
+ 每个表空间的第一个组最开始的3个页面类型固定
    - FSP_HDR：登记整个表空间的属性以及本组所有的区的属性
    - IBUF_BITMAP：存储本组中所有的区的所有页面关于INSERT BUFFER的信息
    - INODE：存储许多称为INODE的数据结构
+ 其余各组最开始的2个页面类型固定
    - XDES：跟FSP_HDR差不多，记录本组的区的属性，只不过FSP_HDR会额外存储一些表空间的属性
    - IBUF_BITMAP：存储本组中所有的区的所有页面关于INSERT BUFFER的信息
+ 段（segment）的概念
    - 存放叶子节点的区的集合就算是一个段，存放非叶子节点的区的集合也算是一个段
    - 一个索引会有2个段，一个叶子节点段，一个非叶子节点段
+ 表中数据较少时，并不会上述生成2个段（2M，浪费空间），而是提出一个碎片区的概念，在一个碎片区中，并不是所有的页都是为了存储同一个段的数据而存在的，碎片区中的页可以用于不同的目的
    - 在刚开始向表中插入数据的时候，段是从某个碎片区**以单个页面为单位**来分配空间的
    - 当某个段已经占用了**32个碎片区页面**后，就会以**完整的区（64页一个区）**为单位来分配存储空间

### 区的分类
+ 空闲的区（FREE）：还没有用到这个区中的任何页面
+ 有剩余空间的碎片区（FREE_FRAG）：碎片区中还有可用的页面
+ 没有剩余空间的碎片区（FULL_FRAG）：表示碎片区中所有页面都被使用，没有空闲页面
+ 附属于某个段的区（FSEG）：每一个索引都可以分为叶子节点段和非叶子节点段，此外还有一些特殊作用的段
+ 处于FREE、FREE_FRAG、FULL_FRAG这三种状态的区都是独立的，直属于表空间
+ 处于FSEG状态的区是附属于某个段的

### XDES Entry结构
![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1634979322288-d5fc08b0-ef2d-4f36-817e-133b63c61819.png)

+ 每个区都对应一个XDES Entry
+ Segment ID：该区所在的段
+ List Node：将XDES Entry结构连成一个链表
+ State：上述区的分类的4个状态
+ Page State Bitmap：16字节，128位，一个区默认64页，每个页对应2个比特位
    - 第一个位表示对应的页是否空闲
    - 第二个比特位还没有用

### XDES Entry链表
+ 先捋一捋向某个段中插入数据的过程：
    - 段中数据较少时，会查看表空间中是否有状态为FREE_FRAG的区，再从该区中取一些零散的页把数据插进去，否则到表空间申请下一个状态为FREE的区，把该区的状态变为FREE_FRAG，再从该区中取一些零散的页插入数据，直到该区中没有空闲的页，该区状态变为FULL_FRAG

如何知道表空间中哪些区是FREE的，哪些是FREE_FRAG的？

**List Node形成链表：**

        * 状态为FREE的区对应的XDES Entry通过List Node形成链表，**此链表直属于表空间**
        * 状态为FREE_FRAG的区对应的XDES Entry通过List Node形成链表，**此链表直属于表空间**
        * 状态为FULL_FRAG的区对应的XDES Entry通过List Node形成链表，**此链表直属于表空间**
    - 段中数据占满32个零散的页后，就直接**申请完整的区**来插入数据
+ 在每个段中，也为该段中的区对应的XDES Entry结构建立了三个链表
    - FREE链表：同一个段中，所有页面是FREE的区对应的XDES Entry结构会被加入到这个链表，**此链表附属于某个段**
    - NOT_FULL链表：同一个段中，仍有空闲空间的区对应的XDES Entry结构会被加入到这个链表，**此链表附属于某个段**
    - FULL链表：同一个段中，已经没有空闲空间的区对应的XDES Entry结构会被加入到这个链表，**此链表附属于某个段**

```sql
CREATE TABLE t (
    c1 INT NOT NULL AUTO_INCREMENT,
    c2 VARCHAR(100),
    c3 VARCHAR(100),
    PRIMARY KEY (c1),
    KEY idx_c2 (c2)
) ENGINE=InnoDB;
```

+ 表t一共两个索引，一个聚簇索引一个二级索引`idx_c2`
    - 这个表有4个段
    - 每个段维护上述3个链表，一共12个链表，加上直属于表空间的3个链表，整个表空间共需要维护15个链表
+ 段在数据量比较大时插入数据的话，会先获取该段NOT_FULL链表的头节点，直接把数据插入到这个头节点对应的区中即可，如果该区的空间已经被用完，就把该节点移动到FULL链表中

### XDES Entry链表基节点
![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1634979298602-587782a7-718c-4bd6-977d-7fda4e193324.png)

+ 在表空间中固定的位置存放基节点，**每一个链表**都对应一个**List Base Node**
    - List Length：链表中一共多少个节点
    - First Node Page Number / First Node Offset 头节点在表空间中的位置
    - Last Node Page Number / Last Node Offset 尾节点在表空间中的位置

### XDES Entry小结
+ 表空间由若干个区组成，每个区对应一个XDES Entry结构
    - 直属于表空间的区对应的XDES Entry结构可以分成FREE / FREE_FRAG / FULL_FRAG 3个链表
    - 每个段可以附属若干个区，每个段中的区对应的XDES Entry结构可以分成 FREE / NOT_NULL / FULL 3个链表
    - 每个链表都对应一个List Base Node 结构，这个结构记录了链表的头、尾节点的位置以及该链表中包含的节点数

### 段的结构
+ 段其实不对应表空间中某一个连续的物理区域，只是一个逻辑上的概念，由若干个零散的页面以及一些完整的区组成。INODE Entry结构记录段中的属性。

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1634979661383-35a3ab3a-73af-4422-8bcb-4b7b194db3b2.png)

+ Segment ID：段编号
+ NOT_FULL_N_USED：NOT_FULL链表中已经使用了多少个页面
+ 3个List Base Node：便于查找某个段中段3个链表的头节点和尾节点
+ Magic Number：标记这个INODE Entry是否已经被初始化
+ Fragment Array Entry：对应一些零散的页面，4字节，表示页面的页号

### FSP_HDR页面（表空间中第一个组的第一个页面）
![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1634980286789-ba5048c8-2778-48d3-9527-2e5719dbaff3.png)

+ File Header：文件头，记录页通用信息
+ File Space Header：表空间头部，记录表空间整体属性信息
+ XDES Entry：区描述信息，存储本组256个区对应的属性信息
+ Empty Space：尚未使用的空间，填充结构，没有实际意义
+ File Trailer：文件尾部，校验页是否完整

#### File Space Header
![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1634980439077-e5283fe5-e27c-4004-b311-4a2a5e124236.png)

+ Space ID：表空间ID
+ Size：当前表空间占有的页面数
+ FREE Limit：尚未被初始化的最小页号
    - 在该字段表示的页号之前的区都被初始化了，之后的区尚未被初始化
+ Space Flags：表空间的一些占用存储空间比较小的属性
+ FRAG_N_USED：FREE_FRAG链表中已使用的页面数量
+ **List Base Node for xxx：3个属于表空间的链表的基节点**
+ Next Unused Segment ID：表空间下一个未使用的Segment ID
    - 新建下一个索引的时候需要创建两个段，用这个id为新的段赋值
+ List Base Node for SEG_INODES_FULL List：SEG_INODES_FULL链表的基节点
+ List Base Node for SEG_INODES_FREE List：SEG_INODES_FREE链表的基节点
    - 每个段对应的INODE Entry结构集中存放到一个类型为INODE的页中，如果表空间中的段特别多，则会有多个INODE Entry结构，可能一个页放不下

#### XDES Entry部分
256个区划分成一组，每组第一个页面存放256个XDES Entry结构。

### XDES页面
与FSP_HDR相比，除了少了File Space Header部分，其余一样。

### IBUF_BITMAP页面
记录Change Buffer。

### INODE页面
![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1635132297383-75738e19-4718-484f-8f18-f344f1141934.png)

+ List Node for INODE Page List：存储上一个INODE页面和下一个INODE页面的指针
+ INODE Entry：段描述信息
+ Empty Space：结构填充，无实际意义

### 系统表空间
+ 表空间ID 是 0

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1635132471020-3be456b8-3f54-443d-b262-c9be9338a8bd.png)

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1635132486714-6de6b553-3d78-4ab9-9f7d-810dd5c92593.png)

+ InnoDB数据字典
    - 使用INSERT语句插入数据时，可能还需要知道：
        * 表属于哪个表空间，表里面多少列
        * 每一列的类型
        * 该表的索引
        * 该表的外键
        * 。。。

InnoDB特意定义了一些列的内部系统表来记录这些元数据：

![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1635132660993-6a26f6ac-d97d-41df-92f6-54896124731f.png)

+ information_schema系统数据库

用户无法访问内部系统表，除非直接解析系统表空间对应文件系统上的文件，所以在information_schema中提供了一些以innodb_sys开头的表，这些表并不是真正的内部系统表，而是存储引擎启动时读取这些表然后填充的，这些表的字段与内部系统表的字段并不完全一样。

### 总结图
![](https://cdn.nlark.com/yuque/0/2021/png/1732113/1635148781402-a0a48e9e-bec1-41b4-81bb-5f771bf7430d.png)



## 并发控制
#### 服务器层 表锁
#### 存储引擎层 行级锁
## 事务
+  ACID 
    -  原子性 atomicity  
整个事务中所有操作要么全部提交成功，要么全部失败回滚 
    -  一致性 consistency  
数据库总是从一个一致性的状态转换到另外一个一致性的状态 
    -  隔离性 isolation  
并发事务之间互相影响的程度 
    -  持久性 durability  
事务提交后，对系统的影响是永久的 
    -  **原子性并不能够完全保证一致性**  
从账户A转一笔钱到账户B上，如果账户A的钱减少了，账户B的钱却没有增加，就认为数据处于不一致的状态。  
多个事务并行进行的情况下，即使保证了每一个事务的原子性，仍然可能导致数据不一致的结果。  
事务1读取账号A的值，然后在这个值上加100。在这两个操作之间事务B修改了账号A的值，在这个操作上增加了100。本来最后的结果应该是A增加了200元，但事实上，事务1最后完成时，账号A只增加了100元。因为事务2的修改结果被事务1覆盖掉了。  
**为了保证并发情况下的一致性，需要引入隔离性。多个事务并发执行后的状态，和它们串行执行后的状态是等价的。**  
**不考虑隔离性的时候，可能导致脏读、幻读和不可重复读的问题（这些问题，其实就是导致无法保证一致性的几种情况）**  
[https://www.zhihu.com/question/30272728/answer/72476703](https://www.zhihu.com/question/30272728/answer/72476703)  
**一致性是最基本的属性，其他三个属性都为了保证一致性而存在** 

 

+  隔离级别 
    -  READ UNCOMMITED 未提交读  
事务中的修改，即使没有提交，对其他事务也是可见的  
**脏读（重点在于修改）：脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的** 
    -  READ COMMITED 提交读（不可重复读）  
一个事务从开始到提交之前，所做的任何修改对其他事务不可见  
**不可重复读（重点在于修改）：执行两次同样的查询，可能会得到不一样的结果** 
    -  REPEATABLE READ**（MySQL默认事务隔离级别，InnoDB通过MVCC解决幻读问题）**  
在同一个事务中多次读取**同样记录**的结果是一致的。但无法解决幻读。  
**幻读（重点在于增删）：同样的条件，第一次和第二次读出来的记录数量不一样** 
    -  SERIALIZABLE 可串行化  
强制事务串行执行。会在读取的每一行数据上都加锁。 

| 隔离级别 | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| --- | --- | --- | --- | --- |
| READ_UNCOMMITTED | ✔️ | ✔️ | ✔️ |  |
| READ_COMMITTED |  | ✔️ | ✔️ |  |
| REPEATABLE_READ |  |  | ✔️ |  |
| SERIALIZABLE |  |  |  | ✔️ |




+  多版本并发控制 MVCC  
MVCC只在READ_COMMITTED和REPEATABLE_READ下工作。

InnoDB的MVCC，在每行记录后面增加两个隐藏的列实现，一列保存**行创建时间（行版本号）**，一列保存**行过期时间或删除时间（行删除标识）**，这里的时间指系统版本号。**每开始一个新的事务，系统版本号都会自动递增。** 

    -  SELECT 
        *  行版本号 <= 当前事务ID  
 确保事务读取的行，要么在事务开始前存在，要么在本事务插入或修改过的 
        *  行删除标识 is NULL or 行删除标识 > 当前事务ID  
 确保事务读取的行，在事务开始前没有被删除 
    -  INSERT 
        * SET 行版本号 = 当前事务ID
    -  DELETE 
        * SET 行删除标识 = 当前事务ID
    -  UPDATE 
        * 插入一行新记录，SET 行版本号 = 当前事务ID，修改旧记录，SET 行删除标识 = 当前事务
    - 上述不是很严谨
    - [MVCC](https://www.cnblogs.com/stevenczp/p/8018986.html)
    - 记录的历史版本放在专门的rollback segment里（undo log）
    - MySQL的一致性读是通过read view实现的

 

## 性能剖析
+  剖析单条查询 
    - SET profiling = 1;
    - SHOW PROFILES;（过时）

```sql
mysql> show profile for query 3;
+----------------------------+----------+
| Status                     | Duration |
+----------------------------+----------+
| starting                   | 0.000215 |
| checking permissions       | 0.000009 |
| Opening tables             | 0.007366 |
| init                       | 0.000019 |
| System lock                | 0.000011 |
| optimizing                 | 0.000219 |
| statistics                 | 0.001201 |
| preparing                  | 0.000626 |
| Creating tmp table         | 0.001533 |
| executing                  | 0.000666 |
| end                        | 0.000011 |
| query end                  | 0.000005 |
| waiting for handler commit | 0.000082 |
| closing tables             | 0.000022 |
| freeing items              | 0.000243 |
| cleaning up                | 0.000026 |
+----------------------------+----------+
16 rows in set, 1 warning (0.00 sec)

mysql> SHOW PROFILES;
+----------+------------+----------------+
| Query_ID | Duration   | Query          |
+----------+------------+----------------+
|        1 | 0.00010600 | show tables    |
|        2 | 0.00006600 | show database  |
|        3 | 0.01225400 | show databases |
+----------+------------+----------------+
3 rows in set, 1 warning (0.00 sec)

mysql> show warnings;
+---------+------+--------------------------------------------------------------------------------------------------------------+
| Level   | Code | Message                                                                                                      |
+---------+------+--------------------------------------------------------------------------------------------------------------+
| Warning | 1287 | 'SHOW PROFILES' is deprecated and will be removed in a future release. Please use Performance Schema instead |
+---------+------+--------------------------------------------------------------------------------------------------------------+
1 row in set (0.00 sec)
```

+  SHOW FULL PROCESSLIST; 
+  EXPLAIN [sql]  

```sql
mysql> explain SELECT * FROM `weather`.manager WHERE id < (SELECT COUNT(1) FROM `weather`.manager);
+----+-------------+---------+------------+-------+------------------------+----------------+---------+------+------+----------+-------------+
| id | select_type | table   | partitions | type  | possible_keys          | key            | key_len | ref  | rows | filtered | Extra       |
+----+-------------+---------+------------+-------+------------------------+----------------+---------+------+------+----------+-------------+
|  1 | PRIMARY     | manager | NULL       | range | PRIMARY,USER_ID_UINDEX | PRIMARY        | 8       | NULL |    5 |   100.00 | Using where |
|  2 | SUBQUERY    | manager | NULL       | index | NULL                   | USER_ID_UINDEX | 8       | NULL |    8 |   100.00 | Using index |
+----+-------------+---------+------------+-------+------------------------+----------------+---------+------+------+----------+-------------+
2 rows in set, 1 warning (0.00 sec)
```

    -  id  
ID值越高优先级越高（越早执行） 
    -  select_type 
        * SIMPLE  简单SELECT，不使用UNION 子查询等
        * PRIMARY  最外层的SELECT（只在有子查询的时候）
        * UNION  UNION中的第二个或后面的SELECT语句
        * DEPENDENT UNION UNION中的第二个或后面的SELECT语句，取决于外面的查询
        * UNION RESULT UNION的结果
        * SUBQUERY 子查询中的第一个SELECT
        * DEPENDENT SUBQUERY 子查询中的第一个SELECT，取决于外面的查询
        * DERIVED 派生表的SELECT，FROM子句的子查询
        * UNCACHEBLE SUBQUERY 一个子查询的结果不能被缓存
    -  table 表名，有时候是第n步执行的结果 
    -  type 访问类型（找到所需行的方式）  
常用的类型有： **ALL, index, range, ref, eq_ref, const, system, NULL（从左到右，性能从差到好）**  
ALL：Full Table Scan， MySQL将遍历全表以找到匹配的行  
index: Full Index Scan，index与ALL区别为index类型只遍历索引树  
range:只检索给定范围的行，使用一个索引来选择行  
ref: 表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值  
eq_ref: 类似ref，区别就在使用的索引是唯一索引，对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件  
const、system: 当MySQL对查询某部分进行优化，并转换为一个常量时，使用这些类型访问。如将主键置于where列表中，MySQL就能将该查询转换为一个常量,system是const类型的特例，当查询的表只有一行的情况下，使用system  
NULL: MySQL在优化过程中分解语句，执行时甚至不用访问表或索引，例如从一个索引列里选取最小值可以通过单独索引查找完成。 
    -  possible_keys 指出MySQL能使用哪个索引在表中找到记录，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询使用 
    -  key 显示MySQL实际决定使用的键 
    -  key_len 索引中使用的字节数 
    -  ref 连接匹配条件，哪些列或常量被用于查找索引列上的值 
    -  rows MySQL估算的找到所需记录所需要读取的行数 
    -  Extra  
Using where:列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候，表示mysql服务器将在存储引擎检索行后再进行过滤  
Using temporary：表示MySQL需要使用临时表来存储结果集，常见于排序和分组查询  
Using filesort：MySQL中无法利用索引完成的排序操作称为“文件排序”  
Using join buffer：改值强调了在获取连接条件时没有使用索引，并且需要连接缓冲区来存储中间结果。如果出现了这个值，那应该注意，根据查询的具体情况可能需要添加索引来改进能。  
Impossible where：这个值强调了where语句会导致没有符合条件的行。  
Select tables optimized away：这个值意味着仅通过使用索引，优化器可能仅从聚合函数结果中返回一行 

 

## Schema与数据类型优化
+  选择越小越简单的数据类型  
简单数据类型的操作通常需要更少的CPU周期。应使用MySQL内建的类型（date，time，datetime）存储日期时间，使用整型存储IP地址。 
+  尽量避免NULL  
可为NULL的列使用更多的存储空间，被索引时需要一个额外的字节。  
如果计划在列上建索引，就应该尽量避免设计成可为NULL的列。 
+  整数   
值的范围为-2^(N-1) ~ 2^(N-1)-1，N为长度。  
MySQL可以指定宽度，例如INT(11)，不限制值的合法范围，只是规定MySQL的交互工具用来显示字符的个数，**对于存储和计算来说，INT(1)和INT(20)是相同的。** 

| JDBCTYPE | 长度（bit） | JAVATYPE |
| --- | --- | --- |
| TINYINT | 8 | byte |
| SMALLINT | 16 | short |
| MEDIUMINT | 24 | - |
| INT | 32 | int |
| BIGINT | 64 | long |


+  实数类型  
不只是为了存储小数部分，也可以使用DECIMAL存储比BIGINT还大的整数。 
    -  DECIMAL  
DECIMAL类型用于存储精确的小数，在MySQL5.0和更高版本支持精确计算，MySQL4.1和更早版本使用浮点运算实现DECIMAL的计算（有精度损失，DECIMAL只是一个存储类型）。  
DECIMAL(x,y)中，x表示有效数字数的精度，x的范围为1～65，y表示小数点后的位数y的范围为0～30  
DECIMAL(6,2)表示的数据范围为-9999.99～9999.99。  
每四个字节存9个数字，DECIMAL(18,9)将使用9个字节（4B整数+4B小数+1B小数点） 
    -  FLOAT 4Byte 
    -  DOUBLE 8Byte  
**MySQL使用DOUBLE作为内部浮点计算的类型** 
+  字符串类型 
    -  VARCHAR 
        * VARCHAR会使用1或2个额外字节记录字符串长度（长度小于等于255Byte时为1个字节，否则为2个字节）
        * 慷慨是不明智的，VARCHAR(5)和VARCHAR(200)，存储`hello`的空间开销时一样的，但是更长的列会消耗更多的内存（MySQL通常会分配固定大小的内存块来保存内部值）。在使用内存临时表和磁盘临时表进行排序或操作时也会有影响。
    -  CHAR  
定长，在确定值的长度情况下优于VARCHAR（VARCHAR需要额外字节记录长度，并且CHAR类型不容易产生碎片）。  
从CHAR(4)和VARCHAR(4)列检索的值并不总是相同，**因为检索从CHAR列删除了尾部的空格**。  

```sql
mysql> insert into test.char_test VALUES ('ab  ', 'ab  ');
mysql> select CONCAT(c, '+'), CONCAT(v, '+') from test.char_test;
+----------------+----------------+
| CONCAT(c, '+') | CONCAT(v, '+') |
+----------------+----------------+
| ab+            | ab  +          |
+----------------+----------------+
1 row in set (0.00 sec)
```

    -  使用ENUM代替字符串类型  
MySQL会根据列表值的数量压缩到一个或者两个字节中，MySQL在内部会将每个值在列表中的位置保存为整数。   
不建议使用数字作为ENUM的枚举值（很容易混乱）。  
**枚举字段按照内部存储的整数进行排序。**  

```sql
create table enum_test (
    e ENUM('fish', 'dog', 'cat') NOT NULL
);
INSERT INTO enum_test VALUES ('fish'), ('dog'), ('cat');

mysql> SELECT e + 0 FROM enum_test;
+-------+
| e + 0 |
+-------+
|     1 |
|     2 |
|     3 |
+-------+
3 rows in set (0.00 sec)
```

```sql
mysql> SELECT * FROM enum_test ORDER BY e DESC;
+------+
| e    |
+------+
| cat  |
| dog  |
| fish |
+------+
3 rows in set (0.00 sec)
```

 

+  时间类型  
MySQL能存储的最小时间粒度为秒。 
    -  DATETIME  
	范围为1001年到9999年。他把日期和时间封装到“YYYYMMDDHHMMSS”的整数中，**与时区无关**，使用8个字节的存储空间。 
    -  TIMESTAMP  
	保存了从1970年1月1日午夜（格林尼治时间）以来的秒数，只使用4个字节的存储空间。只能表示到2038年。  
	如果在多个时区存储和访问数据，TIMESTAMP和DATETIME的行为将很不一样，**前者提供的值和时区有关系**，后者则保留文本表示的日期和时间。 

MySQL采用ANSI标准定义的日期和时间表示方法，如“2021-07-14 17:00:00”，不论是插入timestamp类型还是datetime类型的数据，数据格式均为“YYYY-MM-dd HH24:mm:ss”，如`INSERT INTO time_test VALUES ('2021-07-14 08:00:00')`。 

